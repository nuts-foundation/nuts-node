package didx509

import (
	"crypto/sha1"
	"encoding/base64"
	"errors"
	"fmt"
	"github.com/minio/sha256-simd"
	"github.com/nuts-foundation/go-did/did"
	"github.com/nuts-foundation/nuts-node/pki"
	resolver2 "github.com/nuts-foundation/nuts-node/vdr/resolver"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/mock/gomock"
	"testing"
)

func TestManager_Resolve(t *testing.T) {
	ctrl := gomock.NewController(t)
	validator := pki.NewMockValidator(ctrl)
	resolver := NewResolver(validator)
	metadata := resolver2.ResolveMetadata{}

	otherNameValue := "A_BIG_STRING"
	_, certChain, rootCertificate, _, signingCert, err := BuildCertChain(otherNameValue)
	require.NoError(t, err)
	metadata.X509CertChain = certChain
	metadata.X509CertThumbprint = sha1Sum(signingCert.Raw)
	metadata.X509CertThumbprintS256 = sha256Sum(signingCert.Raw)

	rootDID := did.MustParseDID(fmt.Sprintf("did:x509:0:%s:%s::san:otherName:%s", "sha256", sha256Sum(rootCertificate.Raw), otherNameValue))

	t.Run("test nulls", func(t *testing.T) {
		chain := metadata.X509CertChain
		metadata.X509CertChain = nil
		_, _, err := resolver.Resolve(rootDID, &metadata)
		require.Error(t, err)
		assert.Equal(t, err.Error(), errors.New("x509 rootCert chain is missing").Error())
		metadata.X509CertChain = chain

	})
	t.Run("happy flow", func(t *testing.T) {
		validator.EXPECT().Validate(gomock.Any()).Return(nil)
		resolve, documentMetadata, err := resolver.Resolve(rootDID, &metadata)
		require.NoError(t, err)
		assert.NotNil(t, resolve)
		assert.NotNil(t, documentMetadata)
	})
	t.Run("happy flow 2", func(t *testing.T) {
		metadata.X509CertThumbprintS256 = ""
		validator.EXPECT().Validate(gomock.Any()).Return(nil)
		resolve, documentMetadata, err := resolver.Resolve(rootDID, &metadata)
		require.NoError(t, err)
		assert.NotNil(t, resolve)
		assert.NotNil(t, documentMetadata)
		metadata.X509CertThumbprintS256 = sha256Sum(signingCert.Raw)
	})
	t.Run("happy flow 2", func(t *testing.T) {
		metadata.X509CertThumbprint = ""
		validator.EXPECT().Validate(gomock.Any()).Return(nil)
		resolve, documentMetadata, err := resolver.Resolve(rootDID, &metadata)
		require.NoError(t, err)
		assert.NotNil(t, resolve)
		assert.NotNil(t, documentMetadata)
		metadata.X509CertThumbprint = sha1Sum(signingCert.Raw)
	})
	t.Run("broken chain", func(t *testing.T) {
		expectedErr := errors.New("broken chain")
		validator.EXPECT().Validate(gomock.Any()).Return(expectedErr)
		_, _, err := resolver.Resolve(rootDID, &metadata)
		require.Error(t, err)
		assert.Equal(t, err.Error(), expectedErr.Error())
	})
	t.Run("wrong otherName value", func(t *testing.T) {
		rootDID := did.MustParseDID(fmt.Sprintf("did:x509:0:%s:%s::san:otherName:%s", "sha256", sha256Sum(rootCertificate.Raw), "ANOTHER_BIG_STRING"))
		_, _, err := resolver.Resolve(rootDID, &metadata)
		require.Error(t, err)
		assert.Equal(t, err.Error(), ErrWrongSanOtherName.Error())
	})
	t.Run("wrong hash type value", func(t *testing.T) {
		rootDID := did.MustParseDID(fmt.Sprintf("did:x509:0:%s:%s::san:otherName:%s", "kaas", sha256Sum(rootCertificate.Raw), "ANOTHER_BIG_STRING"))
		_, _, err := resolver.Resolve(rootDID, &metadata)
		require.Error(t, err)
		assert.Equal(t, err.Error(), errors.New("unsupported hash algorithm: kaas").Error())
	})
	t.Run("wrong hash value", func(t *testing.T) {
		rootDID := did.MustParseDID(fmt.Sprintf("did:x509:0:%s:%s::san:otherName:%s", "sha256", "kaas", "ANOTHER_BIG_STRING"))
		_, _, err := resolver.Resolve(rootDID, &metadata)
		require.Error(t, err)
		assert.Equal(t, err.Error(), errors.New("cannot find a certificate with alg: sha256 hash: kaas").Error())
	})
	t.Run("wrong DID type", func(t *testing.T) {
		rootDID := did.MustParseDID("did:kaas:gouda.nl:jonge")
		_, _, err := resolver.Resolve(rootDID, &metadata)
		require.Error(t, err)
		assert.Equal(t, err.Error(), fmt.Errorf("unsupported DID method: %s", "kaas").Error())
	})
	t.Run("wrong x509 did version", func(t *testing.T) {
		rootDID := did.MustParseDID(fmt.Sprintf("did:x509:1:%s:%s::san:otherName:%s", "sha256", sha256Sum(rootCertificate.Raw), "ANOTHER_BIG_STRING"))
		_, _, err := resolver.Resolve(rootDID, &metadata)
		require.Error(t, err)
		assert.Equal(t, err.Error(), ErrDidVersion.Error())
	})
	t.Run("missing x509 did version", func(t *testing.T) {
		rootDID := did.MustParseDID(fmt.Sprintf("did:x509:%s:%s::san:otherName:%s", "sha256Sum", sha256Sum(rootCertificate.Raw), "ANOTHER_BIG_STRING"))
		_, _, err := resolver.Resolve(rootDID, &metadata)
		require.Error(t, err)
		assert.Equal(t, err.Error(), ErrDidMalformed.Error())
	})
}

func sha1Sum(raw []byte) string {
	sum := sha1.Sum(raw)
	return base64.RawURLEncoding.EncodeToString(sum[:])
}

func sha256Sum(bytes []byte) string {
	rootHash := sha256.Sum256(bytes)
	rootHashStr := base64.RawURLEncoding.EncodeToString(rootHash[:])
	return rootHashStr
}

const CREDENTIAL = `eyJhbGciOiJQUzUxMiIsImtpZCI6ImRpZDp4NTA5OjA6c2hhNTEyOjV3Z05uUnFpMkVCNGNJZzRhczZPUWZJd19CVHk3SUd5VHlXYlR4THlpdTduZ05PVkNqSUNDSzNxX1pwYWthV3JOV0N0QUM5WkF6ZXNtcklUNTFLY2RBOjpzYW46b3RoZXJOYW1lOjIuMTYuNTI4LjEuMTAwNy45OS4yMTEwLTEtOTAwMDMwNzg3LVMtOTAwMDAzODAtMDAuMDAwLTExMjIzMzQ0IiwidHlwIjoiSldUIiwieDVjIjpbIi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxuTUlJRlVqQ0NBenFnQXdJQkFnSUlLZHJVdW5hNnVwd3dEUVlKS29aSWh2Y05BUUVMQlFBd1J6RUxNQWtHQTFVRVxuQmhNQ1Rrd3hEVEFMQmdOVkJBb01CRU5KUWtjeEtUQW5CZ05WQkFNTUlGUkZVMVFnV205eVp5QkRVMUFnVUhKcFxuZG1GMFpTQlNiMjkwSUVOQklFY3hNQjRYRFRFM01ETXhOakE1TlRjeU4xb1hEVEk0TVRFeE5EQXdNREF3TUZvd1xuUnpFTE1Ba0dBMVVFQmhNQ1Rrd3hEVEFMQmdOVkJBb01CRU5KUWtjeEtUQW5CZ05WQkFNTUlGUkZVMVFnV205eVxuWnlCRFUxQWdVSEpwZG1GMFpTQlNiMjkwSUVOQklFY3hNSUlDSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQWc4QVxuTUlJQ0NnS0NBZ0VBempwby9ObE9FcUorZUdTeWlWWnZIYmpXYjIvUDg3azMyeHNWZmRtQVhMdHJwN3dJWEFUT1xuMkhTYVJ5RTJvaURaZ0hUV1NZc0VWY2pXd1FrRlhsazlzRkFIQkhFdjNBamdUMzVvOUZyOTRnQnB4RXpJc1JhZVxuNTlqd0dHd3lIN2F5WThUZmxUczZsQllTNDUzMDlVcE1JME52bk5QaFZyZG1abEwwOTB2bGtJR3hTNWdGR1EzS1xucGc2SGdZTW5tWTJIZDNoT0s2ckYvLzY4cEV0TWZMUU4xaG1ZM2V3S1BXajhkanZlTFJvZlA5VVF1ZlYrUDBkbFxuaUhjNnczRmU1OVovNy9qUGhJNDdzd3VWZHRYL0RaUHlab0NXLzFyRTlnZmZFMzRJaE9BWGdlbW1PRjdNUndualxuR0FsUnR2UWFKeHBPQkRqaUFHbEZDMUJxUGx6dXpRVjZ2NU8rbEMrUzNPYWIxTkdweER2VDJWRWc5Mm5QN0M1QlxuRjB4cVAzUGZJSTVVd1o3aVlVZ0gweXZzVzBoU0hFbEttZG50NGw1dkNLWktFd2Y2elB0cU9QWlI5b2t4R1hFQ1xubHUxc1FoSS9IdWxpNWpBQXpyZW1xMTdZZFZOaGNtd1RVY0k5L0FsUkxzOU8xR3ZFTWNtRlJtMDlMYkJiVTZaQ1xuanIrdm54K1hyVlZmOFoycGVvcDFENjlrUTdIbHI1eGIxK2hTTDJGN2pkL0hiUnhuZ1FpclRSVFRRSTdvblFtQVxuT2prQitpR00xLzZJNWYxaUlXZ3pKMFdaa2xVQjlqdUVxQVNiQWNUSmNzbnVOK1lJZXU0L24raU9lZ25heWd1SVxuc0FKaDhBM2llTGREK0J4MHlVdm13czJ6Z0RtZ003SHhtMFZ3R0JGOE1xZHNrekdrSVhoTDNBTUNBd0VBQWFOQ1xuTUVBd0hRWURWUjBPQkJZRUZOUDA0Q0t2ZDFDbUlOS2RnV1ZTcHBQRVJWT1ZNQThHQTFVZEV3RUIvd1FGTUFNQlxuQWY4d0RnWURWUjBQQVFIL0JBUURBZ0VHTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElDQVFDMEFjaUFLVHh2akZCaFxuTmxVd1BkM2tLZ3F1bWM0T0MxMlJqanI5S1pLQXg2bEhJc2RSNEx1UEd0RDdGR2lmdHc5b041UitKZ2dSMUd0TlxuSWlsc0t5djlXaEU0d3NnbzhrRmxoWko2bFlxSlp1dWpSajQzUm1hWnJiN2lRaXZaRmlaL0Fyb2d0RWFFdUNTeVxuUjJCcFZ5d3hXOTBHclRKeG1VOEZNTlBucWM1Y2JvTXdFS2ZpditVZ2lvcUVIWHRBQ2hpYTBBanY2bUJXeFI2a1xuYTdrUVFqVXFldGZnejhSMHJvSlMwUDd3THlqdmJoNkU0bjlIb0tUQ3c3WDdYbHVoWmlHbkxGbGJ4RCtUNmpFa1xuMklZcExoZXlrQTZ0cVQxblQ1TFFPZ2ordXBjVWtXalo2WXhEdkRkdkJaYjNVdzJHaVF5bXVqNVhJeDZlbThEcFxudnpXMWhZeGJtRmRkcjJaR0F6UWpwdDJUQlZTSzRITFJoMUVBVm83djJ1dDBtejlJaUVlZnNBRytKdnFNcUlTNFxuRWVVaGRvUHowU0tUSzJBdHRZUjFGYytIQVNIZ0YvcklEWmF4anBQN0YwR2pYaXJ2VERheWVrWDBWOXE2UDZzUFxuUTZHZWtJZ3Q1YlgvTE91d2s4bG9JVENkbUNrYkgvbmZlWklQRG5EM29nNzhjQTlYek1iL2VqQzFvUFBjVG9LaVxuZHZvcXl1UkwxUHhhMTdMeVhjM2dPa0QzbThtWjhSVzhseUNiKzluQWFYYXRrWi94UVlWcUp2YUt3dkRCUkpwNVxucERuL2lwNmxOOUlwM1dkUElqdWoxd3pwWk04N3k1bVlQQmJWVFYwSng5NGIySVdVWlV0SmVPY3hCRTZjR3RVQVxuOWo0bTR4Tm8vN0RGeHpqdFJMa0c5N0dtMDh5Qzh3PT1cbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0iLCItLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cbk1JSUdyakNDQkphZ0F3SUJBZ0lJTlhLaUtRaDdIQTB3RFFZSktvWklodmNOQVFFTEJRQXdSekVMTUFrR0ExVUVcbkJoTUNUa3d4RFRBTEJnTlZCQW9NQkVOSlFrY3hLVEFuQmdOVkJBTU1JRlJGVTFRZ1dtOXlaeUJEVTFBZ1VISnBcbmRtRjBaU0JTYjI5MElFTkJJRWN4TUI0WERURTNNRE14TmpBNU5UYzFOVm9YRFRJNE1URXhNekF3TURBd01Gb3dcblV6RUxNQWtHQTFVRUJoTUNUa3d4RFRBTEJnTlZCQW9NQkVOSlFrY3hOVEF6QmdOVkJBTU1MRlJGVTFRZ1dtOXlcblp5QkRVMUFnVEdWMlpXd2dNaUJRY21sMllYUmxJRk5sY25acFkyVnpJRU5CSUVjeE1JSUNJakFOQmdrcWhraUdcbjl3MEJBUUVGQUFPQ0FnOEFNSUlDQ2dLQ0FnRUFrdHd0REQrdkdoWjVsSXB0UndybUhNMGRkSndnOEZmSm80L2VcbkM2a3pLVkhJYXlKMStqS1JqQWVFVU1GM3ZDUml5Y1RCL3YyVDZBYmQwUUZocDRuSUowV25tcnNST0hEa3VnRWZcbjBBQUFVbUU5cjB6bXZuR0F1UlpiSWZlNEVLVG00RnJMOUxTekcvWXFTb09jTFNKWnNxdTFHK0pxcW43RW9FNS9cbk1GM2JMYTB5QStORTUvdmRPaFBoMTkwR205QmdBeERIdTFKM2x3ZkNaWmlXT3kxRm1zd1dBdUdQYVBOWWVqbmxcbmZNcGpyYTkvWjk3VGVRdkFUVGxKQnhha093cGJnYm1JUlVNbWlMMFZEZUJaNXZKbEZDSUh1RU5XMWhnc3lKQVlcbml2dGFQZTNYWGoveE83bXZQMGZBblJaeTlnWUwwcUNHSWVzdEdLZHp2cTJJdENJTWUwRlVOWUNMUlkzRlVyeENcblZ2aWJZZXRZbk5xV1lMMGo4eFNXNkJ1MFRvVVJZejJSR3pMWlJrWktneDZxbXdkamhDV3BaRU1LNlJyNjV3RFNcbm9yTXFGU3F2Nk1pZndzQ0JtL1BSQURGWlRrNnZPb1RabHZWMWI2RnlaWm5RK2lwOEllcXpCaG1sd3YxNUhWUjlcblBvRVFkTWtiM1c2ZEh4dmZsMVZ3OXpqb1czTFlDQnpna3d3S3ZIbVhrVVk0ZHo2eGdxSGNLa2ZhWWwvWXdZVVFcbkFVZ3h5YmdacHFGLyswQ0JUSk52eDcrdUhvT3pyakdZbWJ6cUhTT1BXZi94WXIvMUMzN01yd2RUTlpCUFEza3VcbmdkR2l1bS90WjhZeXJ4SXdUSG9XaVpnVk43QlA1RFFqdCtVYkZEV0JueE40cXJuczF1cmh1anZ0Wnlka0NIWitcbkJwRzB2YjhDQXdFQUFhT0NBWkF3Z2dHTU1HZ0dDQ3NHQVFVRkJ3RUJCRnd3V2pCWUJnZ3JCZ0VGQlFjd0FvWk1cbmFIUjBjRG92TDNkM2R5NTFlbWt0Y21WbmFYTjBaWEl0ZEdWemRDNXViQzlqWVdObGNuUnpMM1JsYzNSZmVtOXlcbloxOWpjM0JmY0hKcGRtRjBaVjl5YjI5MFgyTmhYMmN4TG1ObGNqQWRCZ05WSFE0RUZnUVU5TFRHTkRBZUJqWlhcbldTT1VPMHdubnhFclBGWXdEd1lEVlIwVEFRSC9CQVV3QXdFQi96QWZCZ05WSFNNRUdEQVdnQlRUOU9BaXIzZFFcbnBpRFNuWUZsVXFhVHhFVlRsVEJrQmdOVkhTQUVYVEJiTUFvR0NHQ0VFQUdIYjJNTU1FMEdDR0NFRUFHSGIySUVcbk1FRXdQd1lJS3dZQkJRVUhBZ0VXTTJoMGRIQnpPaTh2WVdOalpYQjBZWFJwWlM1NmIzSm5ZM053TG01c0wyTndcbmN5OTFlbWt0Y21WbmFYTjBaWEl1YUhSdGJEQlpCZ05WSFI4RVVqQlFNRTZnVEtCS2hraG9kSFJ3T2k4dmQzZDNcbkxuVjZhUzF5WldkcGMzUmxjaTEwWlhOMExtNXNMMk5rY0M5MFpYTjBYM3B2Y21kZlkzTndYM0J5YVhaaGRHVmZcbmNtOXZkRjlqWVY5bk1TNWpjbXd3RGdZRFZSMFBBUUgvQkFRREFnRUdNQTBHQ1NxR1NJYjNEUUVCQ3dVQUE0SUNcbkFRQ2tBTUlmSnJVWDJ0RWJ1NkEvMkFCNks1d1NPYVNMTVJZOW0zY3RyTzBTL08rakUrOHpoSkxYTGVCRmNMOE5cbjVPdWEwNXNjQ010QVpNS0dxVWFDZDdROCt2b1BCdFpacWVlRVhYaFFmbmQ1OU1HWkdMTnVGTWYyYVhvdDUrRjNcbjNhZ0lrTmtRbzV5WUo0d1ZxamxqN1NyQjF4WE1RMWJnNUpvVk9rYXhRaHNNRWxLNlRQcEdiMGxoVlJuMmhuWmFcblYwRlAyOUdxUitqZktldWZjRWc0b2NnVHpiY3RXdlFWY3FuVWNwWWRHYzRaWG5TNDNNaDNncG10Y3FaNXRXUG9cbldDWUpUUlpYWUhiMUc1dWZjNVU3RHJDUUd4KzBlbVJNbXU1VzFUUW5mRG52Sk1KSkFQVnJNc3hyWDZVdFVnanNcblEzTjBlb2dSTWRtb1ZmMlBiS3VWOFhOQkx1TjRWWXhMeEVPTjluOGdadzV5QXkvWkwxMUFNaDVodTBIdUVpMlhcbjdXOXNiajVidWN1eFpHM0xyZFFVekhlZ3cxN3p0ZmJPclFrMHdEQ0YyWlBYMlA5WFlBQzlPMUFtV3BhZUNvUE5cblYyZkxrT0xpTjVGRVBkSk4yaGVBblNzcDZWdkpxME5oZEVYSkxhNzZ5YlB4R1Q1Vlp2VHFLUXIweFJ6cU92WmFcblQ2clJGMGNjTmRxZ0lMTi9BSlRNS3M2Wk9seDU3Ny9VcklVOXY5YzNhQ00ydEZ4RXFLR2lCRTEzMElaUjZvamxcbkgzOU82dDR1czFnSTF1OWNxSXBMelZwK1hIRjd4L1B1alhaS09KMktyTmU1WXNGZVRxVHNUM0s1ZjdGSTRrU0hcblIveFg1N1Y0T09yMnNNVnQ1d2RzMFR6Qm5zOHJ1MlB3OHN2QkdQUk1GMEkwWEE9PVxuLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLSIsIi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxuTUlJRzZEQ0NCTkNnQXdJQkFnSUlVZlpOWXd1RndBTXdEUVlKS29aSWh2Y05BUUVMQlFBd1V6RUxNQWtHQTFVRVxuQmhNQ1Rrd3hEVEFMQmdOVkJBb01CRU5KUWtjeE5UQXpCZ05WQkFNTUxGUkZVMVFnV205eVp5QkRVMUFnVEdWMlxuWld3Z01pQlFjbWwyWVhSbElGTmxjblpwWTJWeklFTkJJRWN4TUI0WERURTNNRE14TmpFd01URXhObG9YRFRJNFxuTVRFeE1qQXdNREF3TUZvd1pqRUxNQWtHQTFVRUJoTUNUa3d4RFRBTEJnTlZCQW9NQkVOSlFrY3hGekFWQmdOVlxuQkdFTURrNVVVazVNTFRVd01EQXdOVE0xTVM4d0xRWURWUVFERENaVVJWTlVJRlZhU1MxeVpXZHBjM1JsY2lCUVxuY21sMllYUmxJRk5sY25abGNpQkRRU0JITVRDQ0FpSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnSVBBRENDQWdvQ1xuZ2dJQkFMZVIzeHJ1NXhIQnRzODdDV1hvejVBN1dLd2NMQjdZdHNjaEd6OE9aN2l4ZGxuTGxyK2Jta0VqMXNpQ1xuTDdoakNFci9ZaS9ncWxCUjd0Z004SEdzYlRWWE01bG1PaWlsYzIyL0xPVFJQdGFBbWxGN3ZrWis5S21KZFQxSlxuTk11M3BtQVp6bFY3U0o3ZFg4c0hsNFoyYno5cUg1aUkzY1hSM0dhZ2NYemJZMG9WTnhnVGlpcjhQWituMy8vR1xudy9paW94Z1NQL2NpNXgzNTk2aWh2TERGekxTcTU0eWhLS3NPVTAwY1BVL3BZVTdiTDhmaTJXdTN1ZGg0dHppTlxuWThJbFluajhsN3pnRndJcDN2K2w1L1AvWFpxdVhFanIzeEJTanFKUWh5RVE0WGdhcnJTRmdxMlE2VDUyNFRXYlxuWXBqR0lwR2RESDhjMEZxRWRoVVVHMUttbkN5OUJuRDVGZXlLL1hOUWhaK1JDeW1GVXgra1JycjhFQ0VZMG4zNlxuWjcxR1BiUUZuVWZOb3FiN2FsbGMzS0MwWmFlTGNpdEdBNkM4SmVEenBrbEN6d2J1NWZRT0ZMRTZRa04rcGxielxuL2hxekdObWlOaFE1S0RpdG5sZW9kTGNFeVFyUGwwUUV4b1BsTVRyZjZRY3NoQTRZMGJUMFBUZWhIYWVMM1J3MlxuQmFCYUdEbUROZ0x1dmd6R24vd0ZGWWRORU1JSTlGRFY0ZDZDNFE3UFBCcE96Z2Q4Z3Z4VExTQVJIU2pMMHRzT1xuZFBFNHBLQUJsbHJscW5Vb1dvWHQyNTVTUTF5THJvTjRzZUtPc1orSzBEMUJXVlVJZnZYcE1tVytCRmxyY0ZYWlxuL1llbll2VVV6YTVIR2VVNmd3a3M5K0lFak9IaG9hSlBKUUFlc05kc25JSXF6QzNqQWdNQkFBR2pnZ0dyTUlJQlxucHpCMEJnZ3JCZ0VGQlFjQkFRUm9NR1l3WkFZSUt3WUJCUVVITUFLR1dHaDBkSEE2THk5M2QzY3VkWHBwTFhKbFxuWjJsemRHVnlMWFJsYzNRdWJtd3ZZMkZqWlhKMGN5OTBaWE4wWDNwdmNtZGZZM053WDJ4bGRtVnNYekpmY0hKcFxuZG1GMFpWOXpaWEoyYVdObGMxOWpZVjluTVM1alpYSXdIUVlEVlIwT0JCWUVGT1F1a1JtOW13WmF2Ty95UzdrYVxucFYrcXdFNnlNQklHQTFVZEV3RUIvd1FJTUFZQkFmOENBUUF3SHdZRFZSMGpCQmd3Rm9BVTlMVEdOREFlQmpaWFxuV1NPVU8wd25ueEVyUEZZd1pBWURWUjBnQkYwd1d6QUtCZ2hnaEJBQmgyOWpEREJOQmdoZ2hCQUJoMjlpQkRCQlxuTUQ4R0NDc0dBUVVGQndJQkZqTm9kSFJ3Y3pvdkwyRmpZMlZ3ZEdGMGFXVXVlbTl5WjJOemNDNXViQzlqY0hNdlxuZFhwcExYSmxaMmx6ZEdWeUxtaDBiV3d3WlFZRFZSMGZCRjR3WERCYW9GaWdWb1pVYUhSMGNEb3ZMM2QzZHk1MVxuZW1rdGNtVm5hWE4wWlhJdGRHVnpkQzV1YkM5alpIQXZkR1Z6ZEY5NmIzSm5YMk56Y0Y5c1pYWmxiRjh5WDNCeVxuYVhaaGRHVmZjMlZ5ZG1salpYTmZZMkZmWnpFdVkzSnNNQTRHQTFVZER3RUIvd1FFQXdJQkJqQU5CZ2txaGtpR1xuOXcwQkFRc0ZBQU9DQWdFQWJCaWpqVFZzNERhVzM2MytaQnA4SUdqaWhrbHdmVFgzaDdnUHpTN25UTDVJc3RtMlxudXZwTTJsU1NORjh4aDVGdGM4V0V5UE05Q1RWd3R1elBMWHNHQkZCcTFXbkRlWDR4UUZhWVRmZS9wMEZQM21keFxuZkg3ODJyQ2p3ZnhRU0xYM3ljRGowdUlZZDNKcU9oMVFBK0lLMmxaSDd6Qk9TTWpGWTEraFJpQnBOU2xFV1FNWlxuVDdvdytkblFRNDE5L0FUZkF4YjBURm0wVG5CZTY1WFhlc1EzZDVaeElyYVF1NWtacHVPZWJscXlmRHY3ZEpqelxuWlJVMWtpYUhjam1JSEJmZlhLWjM0RkpDNXpEeXRXNXRFb3JpMlpvWmFtY092UTlWWk9GalhubzRodDUraEZlK1xueWZrWTJtSFVQNFBjK3VISkdiRG90SVR2TmR4cHRRYXVwUHlKOGtubGc1Sjk0RjUyRnRIODJUUDdWNGV0NXNReVxueW1kbUxVUnJsWGh5clMwUGJJWkxqdThpU0RhZ3M1ZDBUTUo1ZUl4T3BEZWJZMlYvOVJ1T2plNjFWRkZSbmN3dlxuKy91dU5jYVAwN0E4aXFsa2F6VHdVZmRPQlNEV1YxMjArK09wMFphWk1sN3ZtdTdzMTkwcEQydWdCYk9jNXFmaVxuZW8yRnBBQjhyRlZ1alJOdFVpaVhiVG5Sb3NXOHpTZVRFd0t3UEtmbzJ2Mjc5MEdKZytUMGtkL1UvQkdGckx4N1xuU3hYbFd1bnVsNlZjVkdyTFdCNllRVFEwZ2pQMEhBSzVaWDg2RStWRm95b0gxYVQ0ZGdZVGpTOFg1c1NpNkNkMFxuTGJMWVpCOUxaWTlpSldKZ0tZMnNsQTgvU2xyTXAxa0pEYlYwVTRHQTdRYjRZWXVtM1hrdWhnVEs4Nkk9XG4tLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tIiwiLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlJMFRDQ0JybWdBd0lCQWdJVUZRemtmYWdKT3RlMm5WZkNxOUdLQklncnljWXdEUVlKS29aSWh2Y05BUUVMXG5CUUF3WmpFTE1Ba0dBMVVFQmhNQ1Rrd3hEVEFMQmdOVkJBb01CRU5KUWtjeEZ6QVZCZ05WQkdFTURrNVVVazVNXG5MVFV3TURBd05UTTFNUzh3TFFZRFZRUUREQ1pVUlZOVUlGVmFTUzF5WldkcGMzUmxjaUJRY21sMllYUmxJRk5sXG5jblpsY2lCRFFTQkhNVEFlRncweU5EQTVNamN4TkRBNE1ESmFGdzB5TnpBNU1qY3hOREE0TURGYU1JR25NUXN3XG5DUVlEVlFRR0V3Sk9UREVWTUJNR0ExVUVDQXdNV25WcFpDMUliMnhzWVc1a01SWXdGQVlEVlFRSERBMG5VeTFIXG5Va0ZXUlU1SVFVZEZNU0F3SGdZRFZRUUtEQmRVdzZsemRDQmFiM0puYVc1emRHVnNiR2x1WnlBd01URVNNQkFHXG5BMVVFQlJNSk9UQXdNRE13TnpnM01UTXdNUVlEVlFRRERDcDZiM0puWW1scWFtOTFMblJsYzNRdWFXNTBaV2R5XG5ZWFJwYjI0dWVtOXlaMkpwYW1wdmRTNWpiMjB3Z2dJaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQ0R3QXdnZ0lLXG5Bb0lDQVFDdDVIQTkvQ1IvSC9xQ1hOcUl4M1ptYjJsZ2FMZWFqUFBSRDBaWEVKK3ZQdkQ1bFFWRmVNY1hoaklZXG5wZmo2clI5OWRIVktkcmZKR2gvRmJNQmJDVXFrUS9KWklUd29rTzN2aXR4emYwN1krWUJTeGFZWjhUYnBDY2dTXG4yOEY5eStEOXgwOFAwTFJkeW9lZ3lYdnN3VWZNY0I0Q1RlSkwwcDJETnRCeXB3WVVBM3YrZytuN2oxaHNwV2RQXG5qdnJrRWhmbC9qUnZxKzlhMmgwaW5NQUtWNEVEbmhQcHlqNSs4UHM1NjU4MCsrME1Ca2JER2xRV3lGQktndjc0XG5qZ0lEeS9rYTFvWitzbENCbWRIdEhLRHJOcjNwaGZ1UXkxa3Y1YURHUnNaLzlvZlBQQ01NajZJZzg0ZjVxRWRuXG5KQjk0SlE3MHdBQUxEL2ppR3o5QnRtRjhxbmcvbkFUWk1VWkFSK1dSaitYNEwzeGp0WlFJTDZ2U3ZBSDVSbFhFXG5Za2NobTJpUng5RlVKcXRTYWl5cVNmc05BSjhFS2lJOVVLVVJWK1RQdktQNDg4ZTY5UDdEdHNjMGkvaUNZOU95XG5FanFVRXBBK2FQR1hpbFl0a3B5Skt0VFMwTFRnSVpmL0NXcGhVU1hKSmFheElDK25NT1VSYXlXOTE3c3YycXJYXG5ReFpEUHk5UW5HY0JEZno4Q0lwMUplR0NDQ2U1THhMZXpvMjFLQnh4Y0NBWEwrUWxjZDdXRDdhbGpUT2xreUduXG5hQk1mT0FVOUhBVUQ5MWkvV1hwTDd4b2pJN2M4QjA2MGIyTFZZaFpKMTFmc1dYT2RXZWd2a3o3aHozL3dWbjAxXG42Z2dyTTJqeVBjZjZ3Nkx0OVVrOHFqei85K3Fib29NTkZtR2twcyt5aXJmQ09OM2d0UUlEQVFBQm80SURNekNDXG5BeTh3Z2FRR0ExVWRFUVNCbkRDQm1ZSXFlbTl5WjJKcGFtcHZkUzUwWlhOMExtbHVkR1ZuY21GMGFXOXVMbnB2XG5jbWRpYVdwcWIzVXVZMjl0b0VjR0ExVUZCYUJBRmo0eUxqRTJMalV5T0M0eExqRXdNRGN1T1RrdU1qRXhNQzB4XG5MVGt3TURBek1EYzROeTFUTFRrd01EQXdNemd3TFRBd0xqQXdNQzB4TVRJeU16TTBOS0FpQmdnckJnRUZCUWNJXG5BNkFXTUJRTUNEa3dNREF3TXpnd0JnaGdoQkFCaDI4REF6QU1CZ05WSFJNQkFmOEVBakFBTUI4R0ExVWRJd1FZXG5NQmFBRk9RdWtSbTltd1phdk8veVM3a2FwVitxd0U2eU1JR2VCZ2dyQmdFRkJRY0JBUVNCa1RDQmpqQmVCZ2dyXG5CZ0VGQlFjd0FvWlNhSFIwY0RvdkwzZDNkeTUxZW1rdGNtVm5hWE4wWlhJdGRHVnpkQzV1YkM5allXTmxjblJ6XG5MM1JsYzNSZmRYcHBMWEpsWjJsemRHVnlYM0J5YVhaaGRHVmZjMlZ5ZG1WeVgyTmhYMmN4TG1ObGNqQXNCZ2dyXG5CZ0VGQlFjd0FZWWdhSFIwY0RvdkwyOWpjM0F1ZFhwcExYSmxaMmx6ZEdWeUxYUmxjM1F1Ym13d2dnRUZCZ05WXG5IU0FFZ2Ywd2dmb3dnZmNHQ0dDRUVBR0hiMk1NTUlIcU1EOEdDQ3NHQVFVRkJ3SUJGak5vZEhSd2N6b3ZMMkZqXG5ZMlZ3ZEdGMGFXVXVlbTl5WjJOemNDNXViQzlqY0hNdmRYcHBMWEpsWjJsemRHVnlMbWgwYld3d2dhWUdDQ3NHXG5BUVVGQndJQ01JR1pESUdXUTJWeWRHbG1hV05oWVhRZ2RXbDBjMngxYVhSbGJtUWdaMlZpY25WcGEyVnVJSFJsXG5iaUJpWldodlpYWmxJSFpoYmlCa1pTQlVSVk5VSUhaaGJpQm9aWFFnVlZwSkxYSmxaMmx6ZEdWeUxpQklaWFFnXG5WVnBKTFhKbFoybHpkR1Z5SUdseklHbHVJR2RsWlc0Z1oyVjJZV3dnWVdGdWMzQnlZV3RsYkdscWF5QjJiMjl5XG5JR1YyWlc1MGRXVnNaU0J6WTJoaFpHVXVNQjBHQTFVZEpRUVdNQlFHQ0NzR0FRVUZCd01DQmdnckJnRUZCUWNEXG5BVEJmQmdOVkhSOEVXREJXTUZTZ1VxQlFoazVvZEhSd09pOHZkM2QzTG5WNmFTMXlaV2RwYzNSbGNpMTBaWE4wXG5MbTVzTDJOa2NDOTBaWE4wWDNWNmFTMXlaV2RwYzNSbGNsOXdjbWwyWVhSbFgzTmxjblpsY2w5allWOW5NUzVqXG5jbXd3SFFZRFZSME9CQllFRkE4REJ1aWd6TDBXK0h4NVNVTzEydkhDVklQNk1BNEdBMVVkRHdFQi93UUVBd0lGXG5vREFOQmdrcWhraUc5dzBCQVFzRkFBT0NBZ0VBRjVteWhkak5GT3Jnb2hHL2VGL2F0b1dCSytKM0F5ZmI0WUl2XG4yMGdET2g2eEpuWXNnNmI2V1o4S2F2d0tlWllaNkhTWnhlSnBINm0zMlJpZGRxZGtNMk9zQXZxenFPSTljdWVIXG5zS1ZRemI0b0pobHRhUDdlblRhbTJHblI2OFUzejE4VTJKSWRjQ3NkN0NFc1BjbHpHczEvQnZaTGw4NmptdEV4XG5FM1Q5U3lBM3ZBREpoTE4wMUNPOStzU3V4Q3c1bjFMVWQ1TXFjeldpV2JLcXZOVXhRRE82MXRaUlFkcmdpNG45XG42d0ZxaG8yZ1RuSjRzMFVmaHhpSjRTbzFVMVZ1ZVZkVDJhbEdCK21CTGx0WURIQnE4S2pZY2VkMVN4ZDVBK2x6XG5hSkdYOWc2Y3Y1QjJ0SmoydCtwWVljWkw2MjkwdndJU1pWWXl5Si9hOFdxUUxBVnVTUStvZ1hvcXZXNHdROXNsXG5oeThhN2lZQjVvTzFYMWhWT1p3WHRNOEtEWXlMdFg0ME95WE91bzVpcHJHN24yNjA4Y090Q3Z3OVVKNmZaSHlJXG5xbWsxLzIwd2ZiVHR4OTludVlKSVBCNXRyUWRaM1JyWnRNSlZma1k4d3RtcTVyOGo3cUFLMUwzYkErcDUvVEZEXG5MMUtxay9XS1Y3Y1p5RlFSMlhCeG9qRWlONURndmJQaGw1bThaUnUrZTcxc0hzZUc0ZGp0Rk9RWUNISytKcU9jXG5RT2RqeWYvNWRwdmtxUkQ2VHNSOUw3VHZwRHM4Z1VYTlpFaHhJcThib2huSFNvRnVhSU9ka0VXMjYwL2w2ZWllXG5Temo4RWpmOVpWQTI4czBpOTQ2dmRZbXFVVERGN0Eya2NIRkpUa0xwa1pFY2Y5SS9HU3V0Q2p6MFBLZXRSQm1WXG5JNUs5eStZPVxuLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLSJdLCJ4NXQiOiJlc0l3c3ZLNFdveUxlSmh1VkI3aWY5dlp2eWMifQ.eyJleHAiOjQ4ODIyMzAxMjAsImlzcyI6ImRpZDp4NTA5OjA6c2hhNTEyOjV3Z05uUnFpMkVCNGNJZzRhczZPUWZJd19CVHk3SUd5VHlXYlR4THlpdTduZ05PVkNqSUNDSzNxX1pwYWthV3JOV0N0QUM5WkF6ZXNtcklUNTFLY2RBOjpzYW46b3RoZXJOYW1lOjIuMTYuNTI4LjEuMTAwNy45OS4yMTEwLTEtOTAwMDMwNzg3LVMtOTAwMDAzODAtMDAuMDAwLTExMjIzMzQ0IiwianRpIjoiZDZiYjFmYjEtZjQzMC00M2QwLWIyYjAtMWQ5MTg5ODA3MjgxIiwibmJmIjoxNzI4NjMwMTIwLCJzdWIiOiJkaWQ6d2ViOnRlc3QuY29tOngiLCJ2YyI6eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvMjAxOC9jcmVkZW50aWFscy92MSJdLCJjcmVkZW50aWFsU3ViamVjdCI6W3siaWQiOiJkaWQ6d2ViOnRlc3QuY29tOngiLCJuYW1lIjoiS2xhYXMgdmFhayIsIm90aGVyTmFtZSI6IjIuMTYuNTI4LjEuMTAwNy45OS4yMTEwLTEtOTAwMDMwNzg3LVMtOTAwMDAzODAtMDAuMDAwLTExMjIzMzQ0IiwidXJhTnVtYmVyIjoiOTAwMDAzODAiLCJ1emlOdW1iZXIiOiI5MDAwMzA3ODcifV0sInR5cGUiOlsiVmVyaWZpYWJsZUNyZWRlbnRpYWwiLCJVemlTZXJ2ZXJDZXJ0aWZpY2F0ZUNyZWRlbnRpYWwiXX19.H0qwWR8Ea4K9aGKsEUuTKup2gzzwnuWD9gLCHRpUTp6zUTbBjFUfoaQTZFo8RL39aHQaHgPqG305weTR1FnVyGSWnX_JuM9wYgq0akkEcUUQ-6vDunPa5Fv1LyCpWgfZ-wq0HqXlhPNdoGqxMibq1YEYctXfpaTf8EAv2fu8v3oRLIRBwtZoosChXSHoxIOls9RK-MyqvPfImY1nuu6Q56OblHV5CokKb6-1RgagT6g_sCtaZmnDoYhqsfvemyWyb_bz2y0u6H3yjY-xMF5IC9tfu4uSNIZce06xQP9DY_MX_K7Al4d37i0cMpP1qHTe_yxx9hvbowVa2aWirMdhwVXocWVaXkwgyUxF1pHujj--AG_Iqj6ksMloBmsa-7qi7wGSKfgd4mTa0oudARLRHfoPgp_djAb6VpP0D5PxSxXjEvcctHeSK9wlWs6CeSXMs5eGr-mkCPW-icpSKXJ8gHtArh3wJLbTQ-OACHz76anNMsKC_2t_khFldSqQPWBdJ3d5trr4kfUWiuCDFd4hdouOg2Fr2MZEIwZtlXoNm4PFdU-ciXZNr4Ol3eMnQpMRQQPMNMjhAs9rwBFUtPjQidOavdbrTQvPppoxN0l_0ox_srL6YuL9Kk1zPBsA1UK0at8erdOQdzASpsWdfA_hrlhW6n4oci4kIiWD92Vcreo`
