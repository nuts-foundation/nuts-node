@startuml
participant "Network\n<size:10><i>Engine implementation" as Network
participant PeerManager
participant "Connector\n<size:10><i>Handles outgoing connections</i></size>" as Connector
participant "Protocol\n<size:10><i>Implements specific version, e.g. v1 or v2</i></size>" as Protocol

== Incoming Connection ==

]-> Protocol : Connect()
Protocol -> Protocol : readHeaders() : clientVersions, peerID
Protocol -> PeerManager : register(peerID,\n invokers: map[capability]invoker)
note right : Might be called multiple times\n (e.g. for both v1 and v2)

== Outgoing Connection ==

Network -> Connector : Connect(DID,\n grpcAddress)
note right: Might be fed by VDR subscription or\n bootstrap nodes read from config.
loop each protocol until every capability is supported, descending order
Connector -> Protocol : Connect(DID, grpcAddress)
Protocol -> PeerManager : register(peerID,\n invokers: map[capability]invoker)
end loop

== Invoking Capability ==

Network -> PeerManager : Invoke(receiverDID,\n capability, payload)
note right : Invocations will probably be\n read from a queue, e.g.\n private credentials or messages.\n If they fail they can be retried.\n Or they might be triggered by\n a process inside the protocol.
PeerManager -> PeerManager : findInvoker(peerID,\n capability) : invoker
PeerManager -> Protocol : invoke(payload)
]<- Protocol : send message
@enduml