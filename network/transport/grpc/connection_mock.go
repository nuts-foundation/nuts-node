// Code generated by MockGen. DO NOT EDIT.
// Source: network/transport/grpc/connection.go

// Package grpc is a generated GoMock package.
package grpc

import (
	reflect "reflect"

	transport "github.com/nuts-foundation/nuts-node/network/transport"
	gomock "go.uber.org/mock/gomock"
	status "google.golang.org/grpc/status"
)

// MockConnection is a mock of Connection interface.
type MockConnection struct {
	ctrl     *gomock.Controller
	recorder *MockConnectionMockRecorder
}

// MockConnectionMockRecorder is the mock recorder for MockConnection.
type MockConnectionMockRecorder struct {
	mock *MockConnection
}

// NewMockConnection creates a new mock instance.
func NewMockConnection(ctrl *gomock.Controller) *MockConnection {
	mock := &MockConnection{ctrl: ctrl}
	mock.recorder = &MockConnectionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConnection) EXPECT() *MockConnectionMockRecorder {
	return m.recorder
}

// IsAuthenticated mocks base method.
func (m *MockConnection) IsAuthenticated() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsAuthenticated")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsAuthenticated indicates an expected call of IsAuthenticated.
func (mr *MockConnectionMockRecorder) IsAuthenticated() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAuthenticated", reflect.TypeOf((*MockConnection)(nil).IsAuthenticated))
}

// IsConnected mocks base method.
func (m *MockConnection) IsConnected() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsConnected")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsConnected indicates an expected call of IsConnected.
func (mr *MockConnectionMockRecorder) IsConnected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsConnected", reflect.TypeOf((*MockConnection)(nil).IsConnected))
}

// Peer mocks base method.
func (m *MockConnection) Peer() transport.Peer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Peer")
	ret0, _ := ret[0].(transport.Peer)
	return ret0
}

// Peer indicates an expected call of Peer.
func (mr *MockConnectionMockRecorder) Peer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Peer", reflect.TypeOf((*MockConnection)(nil).Peer))
}

// Send mocks base method.
func (m *MockConnection) Send(protocol Protocol, envelope interface{}, ignoreSoftLimit bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Send", protocol, envelope, ignoreSoftLimit)
	ret0, _ := ret[0].(error)
	return ret0
}

// Send indicates an expected call of Send.
func (mr *MockConnectionMockRecorder) Send(protocol, envelope, ignoreSoftLimit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockConnection)(nil).Send), protocol, envelope, ignoreSoftLimit)
}

// closeError mocks base method.
func (m *MockConnection) closeError() *status.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "closeError")
	ret0, _ := ret[0].(*status.Status)
	return ret0
}

// closeError indicates an expected call of closeError.
func (mr *MockConnectionMockRecorder) closeError() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "closeError", reflect.TypeOf((*MockConnection)(nil).closeError))
}

// disconnect mocks base method.
func (m *MockConnection) disconnect() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "disconnect")
}

// disconnect indicates an expected call of disconnect.
func (mr *MockConnectionMockRecorder) disconnect() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "disconnect", reflect.TypeOf((*MockConnection)(nil).disconnect))
}

// registerStream mocks base method.
func (m *MockConnection) registerStream(protocol Protocol, stream Stream) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "registerStream", protocol, stream)
	ret0, _ := ret[0].(bool)
	return ret0
}

// registerStream indicates an expected call of registerStream.
func (mr *MockConnectionMockRecorder) registerStream(protocol, stream interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "registerStream", reflect.TypeOf((*MockConnection)(nil).registerStream), protocol, stream)
}

// setPeer mocks base method.
func (m *MockConnection) setPeer(peer transport.Peer) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "setPeer", peer)
}

// setPeer indicates an expected call of setPeer.
func (mr *MockConnectionMockRecorder) setPeer(peer interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "setPeer", reflect.TypeOf((*MockConnection)(nil).setPeer), peer)
}

// verifyOrSetPeerID mocks base method.
func (m *MockConnection) verifyOrSetPeerID(id transport.PeerID) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "verifyOrSetPeerID", id)
	ret0, _ := ret[0].(bool)
	return ret0
}

// verifyOrSetPeerID indicates an expected call of verifyOrSetPeerID.
func (mr *MockConnectionMockRecorder) verifyOrSetPeerID(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "verifyOrSetPeerID", reflect.TypeOf((*MockConnection)(nil).verifyOrSetPeerID), id)
}

// waitUntilDisconnected mocks base method.
func (m *MockConnection) waitUntilDisconnected() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "waitUntilDisconnected")
}

// waitUntilDisconnected indicates an expected call of waitUntilDisconnected.
func (mr *MockConnectionMockRecorder) waitUntilDisconnected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "waitUntilDisconnected", reflect.TypeOf((*MockConnection)(nil).waitUntilDisconnected))
}
