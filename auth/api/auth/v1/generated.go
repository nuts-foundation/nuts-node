// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package v1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
)

const (
	JwtBearerAuthScopes = "jwtBearerAuth.Scopes"
)

// Defines values for SignSessionRequestMeans.
const (
	SignSessionRequestMeansDummy      SignSessionRequestMeans = "dummy"
	SignSessionRequestMeansEmployeeid SignSessionRequestMeans = "employeeid"
	SignSessionRequestMeansIrma       SignSessionRequestMeans = "irma"
)

// Defines values for SignSessionResponseMeans.
const (
	SignSessionResponseMeansDummy      SignSessionResponseMeans = "dummy"
	SignSessionResponseMeansEmployeeid SignSessionResponseMeans = "employeeid"
	SignSessionResponseMeansIrma       SignSessionResponseMeans = "irma"
)

// Defines values for TokenIntrospectionResponseAssuranceLevel.
const (
	High        TokenIntrospectionResponseAssuranceLevel = "high"
	Low         TokenIntrospectionResponseAssuranceLevel = "low"
	Substantial TokenIntrospectionResponseAssuranceLevel = "substantial"
)

// Contract defines model for Contract.
type Contract struct {
	// Language Language of the contract in all caps.
	Language           ContractLanguage `json:"language"`
	SignerAttributes   *[]string        `json:"signer_attributes,omitempty"`
	Template           *string          `json:"template,omitempty"`
	TemplateAttributes *[]string        `json:"template_attributes,omitempty"`

	// Type Type of which contract to sign.
	Type ContractType `json:"type"`

	// Version Version of the contract.
	Version ContractVersion `json:"version"`
}

// ContractLanguage Language of the contract in all caps.
type ContractLanguage = string

// ContractResponse defines model for ContractResponse.
type ContractResponse struct {
	// Language Language of the contract in all caps.
	Language ContractLanguage `json:"language"`

	// Message The contract message.
	Message string `json:"message"`

	// Type Type of which contract to sign.
	Type ContractType `json:"type"`

	// Version Version of the contract.
	Version ContractVersion `json:"version"`
}

// ContractSigningRequest defines model for ContractSigningRequest.
type ContractSigningRequest struct {
	// Language Language of the contract in all caps.
	Language ContractLanguage `json:"language"`

	// LegalEntity DID of the organization as registered in the Nuts registry.
	LegalEntity LegalEntity `json:"legalEntity"`

	// Type Type of which contract to sign.
	Type ContractType `json:"type"`

	// ValidFrom ValidFrom describes the time from which this contract should be considered valid
	ValidFrom *string `json:"valid_from,omitempty"`

	// ValidTo ValidTo describes the time until this contract should be considered valid
	ValidTo *string `json:"valid_to,omitempty"`

	// Version Version of the contract.
	Version ContractVersion `json:"version"`
}

// ContractType Type of which contract to sign.
type ContractType = string

// ContractVersion Version of the contract.
type ContractVersion = string

// CreateAccessTokenRequest Request as described in RFC7523 section 2.1
type CreateAccessTokenRequest struct {
	// Assertion Base64 encoded JWT following rfc7523 and the Nuts documentation
	Assertion string `json:"assertion"`

	// GrantType always must contain the value "urn:ietf:params:oauth:grant-type:jwt-bearer"
	GrantType string `json:"grant_type"`
}

// CreateJwtGrantRequest Request for a JWT Grant. The grant can be used during a Access Token Request in the assertion field
type CreateJwtGrantRequest struct {
	Authorizer  string                 `json:"authorizer"`
	Credentials []VerifiableCredential `json:"credentials"`

	// Identity Verifiable Presentation
	Identity  *VerifiablePresentation `json:"identity,omitempty"`
	Requester string                  `json:"requester"`

	// Service The service for which this access token can be used. The right oauth endpoint is selected based on the service.
	Service string `json:"service"`
}

// DrawUpContractRequest defines model for DrawUpContractRequest.
type DrawUpContractRequest struct {
	// Language Language of the contract in all caps.
	Language ContractLanguage `json:"language"`

	// LegalEntity DID of the organization as registered in the Nuts registry.
	LegalEntity LegalEntity `json:"legalEntity"`

	// OrganizationCredential A credential according to the W3C and Nuts specs.
	OrganizationCredential *VerifiableCredential `json:"organizationCredential,omitempty"`

	// Type Type of which contract to sign.
	Type ContractType `json:"type"`

	// ValidDuration The duration this contract is valid, starting from validFrom or current time if validFrom is omitted. Uses this node default when omitted. Valid time units are: 's', 'm', 'h'
	ValidDuration *string `json:"validDuration,omitempty"`

	// ValidFrom validFrom describes the time from which this contract should be considered valid. Current time is used when omitted.
	ValidFrom *string `json:"validFrom,omitempty"`

	// Version Version of the contract.
	Version ContractVersion `json:"version"`
}

// JwtGrantResponse Response with a JWT Grant. It contains a JWT, signed with the private key of the requestor software vendor.
type JwtGrantResponse struct {
	// AuthorizationServerEndpoint The URL that corresponds to the oauth endpoint of the selected service.
	AuthorizationServerEndpoint string `json:"authorization_server_endpoint"`
	BearerToken                 string `json:"bearer_token"`
}

// LegalEntity DID of the organization as registered in the Nuts registry.
type LegalEntity = string

// RequestAccessTokenRequest Request for a JWT Grant and use it as authorization grant to get the access token from the authorizer
type RequestAccessTokenRequest struct {
	Authorizer string `json:"authorizer"`

	// Credentials Verifiable Credentials to be included in the access token. If no VCs are to be included in the access token, the array can be left empty.
	Credentials []VerifiableCredential `json:"credentials"`

	// Identity Verifiable Presentation
	Identity  *VerifiablePresentation `json:"identity,omitempty"`
	Requester string                  `json:"requester"`

	// Service The service for which this access token can be used. The right oauth endpoint is selected based on the service.
	Service string `json:"service"`
}

// SignSessionRequest defines model for SignSessionRequest.
type SignSessionRequest struct {
	Means SignSessionRequestMeans `json:"means"`

	// Params Params are passed to the means. Should be documented in the means documentation.
	Params map[string]interface{} `json:"params"`

	// Payload Base64 encoded payload what needs to be signed.
	Payload string `json:"payload"`
}

// SignSessionRequestMeans defines model for SignSessionRequest.Means.
type SignSessionRequestMeans string

// SignSessionResponse defines model for SignSessionResponse.
type SignSessionResponse struct {
	// Means The means this session uses to sign.
	Means SignSessionResponseMeans `json:"means"`

	// SessionID Unique identifier of this sign session.
	SessionID string `json:"sessionID"`

	// SessionPtr A pointer to a sign session. This is an opaque value which only has meaning in the context of the signing means. Can be an URL, base64 encoded image of a QRCode etc.
	SessionPtr map[string]interface{} `json:"sessionPtr"`
}

// SignSessionResponseMeans The means this session uses to sign.
type SignSessionResponseMeans string

// SignSessionStatusResponse defines model for SignSessionStatusResponse.
type SignSessionStatusResponse struct {
	// Status Status indicates the status of the signing process. Values depend on the implementation of the signing means.
	Status string `json:"status"`

	// VerifiablePresentation Verifiable Presentation
	VerifiablePresentation *VerifiablePresentation `json:"verifiablePresentation,omitempty"`
}

// SignatureVerificationRequest defines model for SignatureVerificationRequest.
type SignatureVerificationRequest struct {
	// VerifiablePresentation Verifiable Presentation
	VerifiablePresentation VerifiablePresentation `json:"VerifiablePresentation"`

	// CheckTime Moment in time to check the validity of the signature. If omitted, the current time is used.
	CheckTime *string `json:"checkTime,omitempty"`
}

// SignatureVerificationResponse Contains the signature verification result.
type SignatureVerificationResponse struct {
	// Credentials Key value pairs containing claims and their values.
	Credentials *map[string]interface{} `json:"credentials,omitempty"`

	// IssuerAttributes Key vale pairs containing the attributes of the issuer.
	IssuerAttributes *map[string]interface{} `json:"issuerAttributes,omitempty"`

	// Validity Indicates the validity of the signature.
	Validity bool `json:"validity"`

	// VpType Type of Verifiable credential.
	VpType *string `json:"vpType,omitempty"`
}

// TokenIntrospectionRequest Token introspection request as described in RFC7662 section 2.1
type TokenIntrospectionRequest struct {
	Token string `json:"token"`
}

// TokenIntrospectionResponse Token introspection response as described in RFC7662 section 2.2
type TokenIntrospectionResponse struct {
	// Active True if the token is active, false if the token is expired, malformed etc.
	Active bool `json:"active"`

	// AssuranceLevel Assurance level of the identity of the End-User.
	AssuranceLevel *TokenIntrospectionResponseAssuranceLevel `json:"assurance_level,omitempty"`

	// Aud As per rfc7523 https://tools.ietf.org/html/rfc7523>, the aud must be the
	// token endpoint. This can be taken from the Nuts registry.
	Aud *string `json:"aud,omitempty"`

	// Email End-User's preferred e-mail address. Should be a personal email and can be used to uniquely identify a user. Just like the email used for an account.
	Email *string `json:"email,omitempty"`
	Exp   *int    `json:"exp,omitempty"`

	// FamilyName Surname(s) or last name(s) of the End-User.
	FamilyName *string `json:"family_name,omitempty"`
	Iat        *int    `json:"iat,omitempty"`

	// Initials Initials of the End-User.
	Initials *string `json:"initials,omitempty"`

	// Iss The subject (not a Nuts subject) contains the DID of the authorizer.
	Iss *string `json:"iss,omitempty"`

	// Osi encoded ops signature. (TBD)
	Osi *string `json:"osi,omitempty"`

	// Prefix Surname prefix
	Prefix *string `json:"prefix,omitempty"`

	// ResolvedVCs credentials resolved from `vcs` (VC IDs). It contains only those VCs that could be resolved.
	ResolvedVCs *[]VerifiableCredential `json:"resolvedVCs,omitempty"`
	Service     *string                 `json:"service,omitempty"`

	// Sub The subject is always the acting party, thus the care organization requesting access to data.
	Sub *string `json:"sub,omitempty"`

	// UserRole Role of the End-User.
	UserRole *string `json:"user_role,omitempty"`

	// Username Identifier uniquely identifying the End-User's account in the issuing system.
	Username *string   `json:"username,omitempty"`
	Vcs      *[]string `json:"vcs,omitempty"`
}

// TokenIntrospectionResponseAssuranceLevel Assurance level of the identity of the End-User.
type TokenIntrospectionResponseAssuranceLevel string

// IntrospectAccessTokenFormdataBody defines parameters for IntrospectAccessToken.
type IntrospectAccessTokenFormdataBody struct {
	// Token JWT access token
	Token string `form:"token" json:"token"`
}

// VerifyAccessTokenParams defines parameters for VerifyAccessToken.
type VerifyAccessTokenParams struct {
	Authorization string `json:"Authorization"`
}

// GetContractByTypeParams defines parameters for GetContractByType.
type GetContractByTypeParams struct {
	// Version The version of this contract. If omitted, the most recent version will be returned
	Version  *string `form:"version,omitempty" json:"version,omitempty"`
	Language *string `form:"language,omitempty" json:"language,omitempty"`
}

// IntrospectAccessTokenFormdataRequestBody defines body for IntrospectAccessToken for application/x-www-form-urlencoded ContentType.
type IntrospectAccessTokenFormdataRequestBody IntrospectAccessTokenFormdataBody

// DrawUpContractJSONRequestBody defines body for DrawUpContract for application/json ContentType.
type DrawUpContractJSONRequestBody = DrawUpContractRequest

// CreateJwtGrantJSONRequestBody defines body for CreateJwtGrant for application/json ContentType.
type CreateJwtGrantJSONRequestBody = CreateJwtGrantRequest

// RequestAccessTokenJSONRequestBody defines body for RequestAccessToken for application/json ContentType.
type RequestAccessTokenJSONRequestBody = RequestAccessTokenRequest

// CreateSignSessionJSONRequestBody defines body for CreateSignSession for application/json ContentType.
type CreateSignSessionJSONRequestBody = SignSessionRequest

// VerifySignatureJSONRequestBody defines body for VerifySignature for application/json ContentType.
type VerifySignatureJSONRequestBody = SignatureVerificationRequest

// CreateAccessTokenFormdataRequestBody defines body for CreateAccessToken for application/x-www-form-urlencoded ContentType.
type CreateAccessTokenFormdataRequestBody = CreateAccessTokenRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Introspection endpoint to retrieve information from an Access Token as described by RFC7662
	// (POST /internal/auth/v1/accesstoken/introspect)
	IntrospectAccessToken(ctx echo.Context) error
	// Verifies the provided access token
	// (HEAD /internal/auth/v1/accesstoken/verify)
	VerifyAccessToken(ctx echo.Context, params VerifyAccessTokenParams) error
	// Draw up a contract using a specified contract template, language and version
	// (PUT /internal/auth/v1/contract/drawup)
	DrawUpContract(ctx echo.Context) error
	// Create a JWT Grant
	// (POST /internal/auth/v1/jwt-grant)
	CreateJwtGrant(ctx echo.Context) error
	// Request an access token from the authorizer
	// (POST /internal/auth/v1/request-access-token)
	RequestAccessToken(ctx echo.Context) error
	// Create a signing session for a supported means.
	// (POST /internal/auth/v1/signature/session)
	CreateSignSession(ctx echo.Context) error
	// Get the current status of a signing session
	// (GET /internal/auth/v1/signature/session/{sessionID})
	GetSignSessionStatus(ctx echo.Context, sessionID string) error
	// Verify a signature in the form of a verifiable presentation
	// (PUT /internal/auth/v1/signature/verify)
	VerifySignature(ctx echo.Context) error
	// Create an access token using a JWT as authorization grant
	// (POST /n2n/auth/v1/accesstoken)
	CreateAccessToken(ctx echo.Context) error
	// Get a contract by type and version
	// (GET /public/auth/v1/contract/{contractType})
	GetContractByType(ctx echo.Context, contractType string, params GetContractByTypeParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// IntrospectAccessToken converts echo context to params.
func (w *ServerInterfaceWrapper) IntrospectAccessToken(ctx echo.Context) error {
	var err error

	ctx.Set(JwtBearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.IntrospectAccessToken(ctx)
	return err
}

// VerifyAccessToken converts echo context to params.
func (w *ServerInterfaceWrapper) VerifyAccessToken(ctx echo.Context) error {
	var err error

	ctx.Set(JwtBearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params VerifyAccessTokenParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Authorization, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Authorization: %s", err))
		}

		params.Authorization = Authorization
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Authorization is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VerifyAccessToken(ctx, params)
	return err
}

// DrawUpContract converts echo context to params.
func (w *ServerInterfaceWrapper) DrawUpContract(ctx echo.Context) error {
	var err error

	ctx.Set(JwtBearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DrawUpContract(ctx)
	return err
}

// CreateJwtGrant converts echo context to params.
func (w *ServerInterfaceWrapper) CreateJwtGrant(ctx echo.Context) error {
	var err error

	ctx.Set(JwtBearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateJwtGrant(ctx)
	return err
}

// RequestAccessToken converts echo context to params.
func (w *ServerInterfaceWrapper) RequestAccessToken(ctx echo.Context) error {
	var err error

	ctx.Set(JwtBearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RequestAccessToken(ctx)
	return err
}

// CreateSignSession converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSignSession(ctx echo.Context) error {
	var err error

	ctx.Set(JwtBearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateSignSession(ctx)
	return err
}

// GetSignSessionStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetSignSessionStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "sessionID" -------------
	var sessionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionID", runtime.ParamLocationPath, ctx.Param("sessionID"), &sessionID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sessionID: %s", err))
	}

	ctx.Set(JwtBearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSignSessionStatus(ctx, sessionID)
	return err
}

// VerifySignature converts echo context to params.
func (w *ServerInterfaceWrapper) VerifySignature(ctx echo.Context) error {
	var err error

	ctx.Set(JwtBearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VerifySignature(ctx)
	return err
}

// CreateAccessToken converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAccessToken(ctx echo.Context) error {
	var err error

	ctx.Set(JwtBearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAccessToken(ctx)
	return err
}

// GetContractByType converts echo context to params.
func (w *ServerInterfaceWrapper) GetContractByType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "contractType" -------------
	var contractType string

	err = runtime.BindStyledParameterWithLocation("simple", false, "contractType", runtime.ParamLocationPath, ctx.Param("contractType"), &contractType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contractType: %s", err))
	}

	ctx.Set(JwtBearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContractByTypeParams
	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", ctx.QueryParams(), &params.Version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// ------------- Optional query parameter "language" -------------

	err = runtime.BindQueryParameter("form", true, false, "language", ctx.QueryParams(), &params.Language)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter language: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContractByType(ctx, contractType, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/internal/auth/v1/accesstoken/introspect", wrapper.IntrospectAccessToken)
	router.HEAD(baseURL+"/internal/auth/v1/accesstoken/verify", wrapper.VerifyAccessToken)
	router.PUT(baseURL+"/internal/auth/v1/contract/drawup", wrapper.DrawUpContract)
	router.POST(baseURL+"/internal/auth/v1/jwt-grant", wrapper.CreateJwtGrant)
	router.POST(baseURL+"/internal/auth/v1/request-access-token", wrapper.RequestAccessToken)
	router.POST(baseURL+"/internal/auth/v1/signature/session", wrapper.CreateSignSession)
	router.GET(baseURL+"/internal/auth/v1/signature/session/:sessionID", wrapper.GetSignSessionStatus)
	router.PUT(baseURL+"/internal/auth/v1/signature/verify", wrapper.VerifySignature)
	router.POST(baseURL+"/n2n/auth/v1/accesstoken", wrapper.CreateAccessToken)
	router.GET(baseURL+"/public/auth/v1/contract/:contractType", wrapper.GetContractByType)

}

type IntrospectAccessTokenRequestObject struct {
	Body *IntrospectAccessTokenFormdataRequestBody
}

type IntrospectAccessTokenResponseObject interface {
	VisitIntrospectAccessTokenResponse(w http.ResponseWriter) error
}

type IntrospectAccessToken200JSONResponse TokenIntrospectionResponse

func (response IntrospectAccessToken200JSONResponse) VisitIntrospectAccessTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type VerifyAccessTokenRequestObject struct {
	Params VerifyAccessTokenParams
}

type VerifyAccessTokenResponseObject interface {
	VisitVerifyAccessTokenResponse(w http.ResponseWriter) error
}

type VerifyAccessToken200Response struct {
}

func (response VerifyAccessToken200Response) VisitVerifyAccessTokenResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type VerifyAccessToken403Response struct {
}

func (response VerifyAccessToken403Response) VisitVerifyAccessTokenResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type DrawUpContractRequestObject struct {
	Body *DrawUpContractJSONRequestBody
}

type DrawUpContractResponseObject interface {
	VisitDrawUpContractResponse(w http.ResponseWriter) error
}

type DrawUpContract200JSONResponse ContractResponse

func (response DrawUpContract200JSONResponse) VisitDrawUpContractResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DrawUpContractdefaultApplicationProblemPlusJSONResponse struct {
	Body struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
	StatusCode int
}

func (response DrawUpContractdefaultApplicationProblemPlusJSONResponse) VisitDrawUpContractResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateJwtGrantRequestObject struct {
	Body *CreateJwtGrantJSONRequestBody
}

type CreateJwtGrantResponseObject interface {
	VisitCreateJwtGrantResponse(w http.ResponseWriter) error
}

type CreateJwtGrant200JSONResponse JwtGrantResponse

func (response CreateJwtGrant200JSONResponse) VisitCreateJwtGrantResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateJwtGrantdefaultApplicationProblemPlusJSONResponse struct {
	Body struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
	StatusCode int
}

func (response CreateJwtGrantdefaultApplicationProblemPlusJSONResponse) VisitCreateJwtGrantResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type RequestAccessTokenRequestObject struct {
	Body *RequestAccessTokenJSONRequestBody
}

type RequestAccessTokenResponseObject interface {
	VisitRequestAccessTokenResponse(w http.ResponseWriter) error
}

type RequestAccessToken200JSONResponse AccessTokenResponse

func (response RequestAccessToken200JSONResponse) VisitRequestAccessTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RequestAccessTokendefaultApplicationProblemPlusJSONResponse struct {
	Body struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
	StatusCode int
}

func (response RequestAccessTokendefaultApplicationProblemPlusJSONResponse) VisitRequestAccessTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateSignSessionRequestObject struct {
	Body *CreateSignSessionJSONRequestBody
}

type CreateSignSessionResponseObject interface {
	VisitCreateSignSessionResponse(w http.ResponseWriter) error
}

type CreateSignSession201JSONResponse SignSessionResponse

func (response CreateSignSession201JSONResponse) VisitCreateSignSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateSignSessiondefaultApplicationProblemPlusJSONResponse struct {
	Body struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
	StatusCode int
}

func (response CreateSignSessiondefaultApplicationProblemPlusJSONResponse) VisitCreateSignSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetSignSessionStatusRequestObject struct {
	SessionID string `json:"sessionID"`
}

type GetSignSessionStatusResponseObject interface {
	VisitGetSignSessionStatusResponse(w http.ResponseWriter) error
}

type GetSignSessionStatus200JSONResponse SignSessionStatusResponse

func (response GetSignSessionStatus200JSONResponse) VisitGetSignSessionStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSignSessionStatusdefaultApplicationProblemPlusJSONResponse struct {
	Body struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
	StatusCode int
}

func (response GetSignSessionStatusdefaultApplicationProblemPlusJSONResponse) VisitGetSignSessionStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type VerifySignatureRequestObject struct {
	Body *VerifySignatureJSONRequestBody
}

type VerifySignatureResponseObject interface {
	VisitVerifySignatureResponse(w http.ResponseWriter) error
}

type VerifySignature200JSONResponse SignatureVerificationResponse

func (response VerifySignature200JSONResponse) VisitVerifySignatureResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type VerifySignaturedefaultApplicationProblemPlusJSONResponse struct {
	Body struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
	StatusCode int
}

func (response VerifySignaturedefaultApplicationProblemPlusJSONResponse) VisitVerifySignatureResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateAccessTokenRequestObject struct {
	Body *CreateAccessTokenFormdataRequestBody
}

type CreateAccessTokenResponseObject interface {
	VisitCreateAccessTokenResponse(w http.ResponseWriter) error
}

type CreateAccessToken200JSONResponse AccessTokenResponse

func (response CreateAccessToken200JSONResponse) VisitCreateAccessTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateAccessToken400JSONResponse AccessTokenRequestFailedResponse

func (response CreateAccessToken400JSONResponse) VisitCreateAccessTokenResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetContractByTypeRequestObject struct {
	ContractType string `json:"contractType"`
	Params       GetContractByTypeParams
}

type GetContractByTypeResponseObject interface {
	VisitGetContractByTypeResponse(w http.ResponseWriter) error
}

type GetContractByType200JSONResponse Contract

func (response GetContractByType200JSONResponse) VisitGetContractByTypeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetContractByTypedefaultApplicationProblemPlusJSONResponse struct {
	Body struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
	StatusCode int
}

func (response GetContractByTypedefaultApplicationProblemPlusJSONResponse) VisitGetContractByTypeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Introspection endpoint to retrieve information from an Access Token as described by RFC7662
	// (POST /internal/auth/v1/accesstoken/introspect)
	IntrospectAccessToken(ctx context.Context, request IntrospectAccessTokenRequestObject) (IntrospectAccessTokenResponseObject, error)
	// Verifies the provided access token
	// (HEAD /internal/auth/v1/accesstoken/verify)
	VerifyAccessToken(ctx context.Context, request VerifyAccessTokenRequestObject) (VerifyAccessTokenResponseObject, error)
	// Draw up a contract using a specified contract template, language and version
	// (PUT /internal/auth/v1/contract/drawup)
	DrawUpContract(ctx context.Context, request DrawUpContractRequestObject) (DrawUpContractResponseObject, error)
	// Create a JWT Grant
	// (POST /internal/auth/v1/jwt-grant)
	CreateJwtGrant(ctx context.Context, request CreateJwtGrantRequestObject) (CreateJwtGrantResponseObject, error)
	// Request an access token from the authorizer
	// (POST /internal/auth/v1/request-access-token)
	RequestAccessToken(ctx context.Context, request RequestAccessTokenRequestObject) (RequestAccessTokenResponseObject, error)
	// Create a signing session for a supported means.
	// (POST /internal/auth/v1/signature/session)
	CreateSignSession(ctx context.Context, request CreateSignSessionRequestObject) (CreateSignSessionResponseObject, error)
	// Get the current status of a signing session
	// (GET /internal/auth/v1/signature/session/{sessionID})
	GetSignSessionStatus(ctx context.Context, request GetSignSessionStatusRequestObject) (GetSignSessionStatusResponseObject, error)
	// Verify a signature in the form of a verifiable presentation
	// (PUT /internal/auth/v1/signature/verify)
	VerifySignature(ctx context.Context, request VerifySignatureRequestObject) (VerifySignatureResponseObject, error)
	// Create an access token using a JWT as authorization grant
	// (POST /n2n/auth/v1/accesstoken)
	CreateAccessToken(ctx context.Context, request CreateAccessTokenRequestObject) (CreateAccessTokenResponseObject, error)
	// Get a contract by type and version
	// (GET /public/auth/v1/contract/{contractType})
	GetContractByType(ctx context.Context, request GetContractByTypeRequestObject) (GetContractByTypeResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// IntrospectAccessToken operation middleware
func (sh *strictHandler) IntrospectAccessToken(ctx echo.Context) error {
	var request IntrospectAccessTokenRequestObject

	if form, err := ctx.FormParams(); err == nil {
		var body IntrospectAccessTokenFormdataRequestBody
		if err := runtime.BindForm(&body, form, nil, nil); err != nil {
			return err
		}
		request.Body = &body
	} else {
		return err
	}

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.IntrospectAccessToken(ctx.Request().Context(), request.(IntrospectAccessTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "IntrospectAccessToken")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(IntrospectAccessTokenResponseObject); ok {
		return validResponse.VisitIntrospectAccessTokenResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// VerifyAccessToken operation middleware
func (sh *strictHandler) VerifyAccessToken(ctx echo.Context, params VerifyAccessTokenParams) error {
	var request VerifyAccessTokenRequestObject

	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.VerifyAccessToken(ctx.Request().Context(), request.(VerifyAccessTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "VerifyAccessToken")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(VerifyAccessTokenResponseObject); ok {
		return validResponse.VisitVerifyAccessTokenResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DrawUpContract operation middleware
func (sh *strictHandler) DrawUpContract(ctx echo.Context) error {
	var request DrawUpContractRequestObject

	var body DrawUpContractJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DrawUpContract(ctx.Request().Context(), request.(DrawUpContractRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DrawUpContract")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(DrawUpContractResponseObject); ok {
		return validResponse.VisitDrawUpContractResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateJwtGrant operation middleware
func (sh *strictHandler) CreateJwtGrant(ctx echo.Context) error {
	var request CreateJwtGrantRequestObject

	var body CreateJwtGrantJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateJwtGrant(ctx.Request().Context(), request.(CreateJwtGrantRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateJwtGrant")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(CreateJwtGrantResponseObject); ok {
		return validResponse.VisitCreateJwtGrantResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// RequestAccessToken operation middleware
func (sh *strictHandler) RequestAccessToken(ctx echo.Context) error {
	var request RequestAccessTokenRequestObject

	var body RequestAccessTokenJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RequestAccessToken(ctx.Request().Context(), request.(RequestAccessTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RequestAccessToken")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(RequestAccessTokenResponseObject); ok {
		return validResponse.VisitRequestAccessTokenResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateSignSession operation middleware
func (sh *strictHandler) CreateSignSession(ctx echo.Context) error {
	var request CreateSignSessionRequestObject

	var body CreateSignSessionJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateSignSession(ctx.Request().Context(), request.(CreateSignSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateSignSession")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(CreateSignSessionResponseObject); ok {
		return validResponse.VisitCreateSignSessionResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetSignSessionStatus operation middleware
func (sh *strictHandler) GetSignSessionStatus(ctx echo.Context, sessionID string) error {
	var request GetSignSessionStatusRequestObject

	request.SessionID = sessionID

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetSignSessionStatus(ctx.Request().Context(), request.(GetSignSessionStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSignSessionStatus")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetSignSessionStatusResponseObject); ok {
		return validResponse.VisitGetSignSessionStatusResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// VerifySignature operation middleware
func (sh *strictHandler) VerifySignature(ctx echo.Context) error {
	var request VerifySignatureRequestObject

	var body VerifySignatureJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.VerifySignature(ctx.Request().Context(), request.(VerifySignatureRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "VerifySignature")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(VerifySignatureResponseObject); ok {
		return validResponse.VisitVerifySignatureResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateAccessToken operation middleware
func (sh *strictHandler) CreateAccessToken(ctx echo.Context) error {
	var request CreateAccessTokenRequestObject

	if form, err := ctx.FormParams(); err == nil {
		var body CreateAccessTokenFormdataRequestBody
		if err := runtime.BindForm(&body, form, nil, nil); err != nil {
			return err
		}
		request.Body = &body
	} else {
		return err
	}

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateAccessToken(ctx.Request().Context(), request.(CreateAccessTokenRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateAccessToken")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(CreateAccessTokenResponseObject); ok {
		return validResponse.VisitCreateAccessTokenResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetContractByType operation middleware
func (sh *strictHandler) GetContractByType(ctx echo.Context, contractType string, params GetContractByTypeParams) error {
	var request GetContractByTypeRequestObject

	request.ContractType = contractType
	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetContractByType(ctx.Request().Context(), request.(GetContractByTypeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetContractByType")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetContractByTypeResponseObject); ok {
		return validResponse.VisitGetContractByTypeResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}
