// Code generated by schema-generate. DO NOT EDIT.

package pe

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Constraints 
type Constraints struct {
  Fields []Field `json:"fields,omitempty"`
  IsHolder []*IsHolderItems `json:"is_holder,omitempty"`
  LimitDisclosure string `json:"limit_disclosure,omitempty"`
  SameSubject []*SameSubjectItems `json:"same_subject,omitempty"`
  Statuses *Statuses `json:"statuses,omitempty"`
  SubjectIsIssuer string `json:"subject_is_issuer,omitempty"`
}

// Frame
type Frame struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// InputDescriptor 
type InputDescriptor struct {
  Constraints *Constraints `json:"constraints"`
  Format *PresentationDefinitionClaimFormatDesignations `json:"format,omitempty"`
  Group []string `json:"group,omitempty"`
  Id string `json:"id"`
  Name string `json:"name,omitempty"`
  Purpose string `json:"purpose,omitempty"`
}

// IsHolderItems 
type IsHolderItems struct {
  Directive string `json:"directive"`
  FieldId []string `json:"field_id"`
}

// PresentationDefinition 
type PresentationDefinition struct {
  Format *PresentationDefinitionClaimFormatDesignations `json:"format,omitempty"`
  Frame *Frame `json:"frame,omitempty"`
  Id string `json:"id"`
  InputDescriptors []*InputDescriptor `json:"input_descriptors"`
  Name string `json:"name,omitempty"`
  Purpose string `json:"purpose,omitempty"`
  SubmissionRequirements []*SubmissionRequirement `json:"submission_requirements,omitempty"`
}

// PresentationDefinitionClaimFormatDesignations 
type PresentationDefinitionClaimFormatDesignations struct {
}

// SameSubjectItems 
type SameSubjectItems struct {
  Directive string `json:"directive"`
  FieldId []string `json:"field_id"`
}

// StatusDirective 
type StatusDirective struct {
  Directive string `json:"directive,omitempty"`
  Type []string `json:"type,omitempty"`
}

// Statuses 
type Statuses struct {
  Active *StatusDirective `json:"active,omitempty"`
  Revoked *StatusDirective `json:"revoked,omitempty"`
  Suspended *StatusDirective `json:"suspended,omitempty"`
}

// SubmissionRequirement 
type SubmissionRequirement struct {
}

func (strct *Constraints) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "fields" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"fields\": ")
	if tmp, err := json.Marshal(strct.Fields); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "is_holder" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"is_holder\": ")
	if tmp, err := json.Marshal(strct.IsHolder); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "limit_disclosure" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"limit_disclosure\": ")
	if tmp, err := json.Marshal(strct.LimitDisclosure); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "same_subject" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"same_subject\": ")
	if tmp, err := json.Marshal(strct.SameSubject); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "statuses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"statuses\": ")
	if tmp, err := json.Marshal(strct.Statuses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "subject_is_issuer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"subject_is_issuer\": ")
	if tmp, err := json.Marshal(strct.SubjectIsIssuer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Constraints) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "fields":
            if err := json.Unmarshal([]byte(v), &strct.Fields); err != nil {
                return err
             }
        case "is_holder":
            if err := json.Unmarshal([]byte(v), &strct.IsHolder); err != nil {
                return err
             }
        case "limit_disclosure":
            if err := json.Unmarshal([]byte(v), &strct.LimitDisclosure); err != nil {
                return err
             }
        case "same_subject":
            if err := json.Unmarshal([]byte(v), &strct.SameSubject); err != nil {
                return err
             }
        case "statuses":
            if err := json.Unmarshal([]byte(v), &strct.Statuses); err != nil {
                return err
             }
        case "subject_is_issuer":
            if err := json.Unmarshal([]byte(v), &strct.SubjectIsIssuer); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Frame) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Frame) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *InputDescriptor) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Constraints" field is required
    if strct.Constraints == nil {
        return nil, errors.New("constraints is a required field")
    }
    // Marshal the "constraints" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"constraints\": ")
	if tmp, err := json.Marshal(strct.Constraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "group" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"group\": ")
	if tmp, err := json.Marshal(strct.Group); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "purpose" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"purpose\": ")
	if tmp, err := json.Marshal(strct.Purpose); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InputDescriptor) UnmarshalJSON(b []byte) error {
    constraintsReceived := false
    idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "constraints":
            if err := json.Unmarshal([]byte(v), &strct.Constraints); err != nil {
                return err
             }
            constraintsReceived = true
        case "format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "group":
            if err := json.Unmarshal([]byte(v), &strct.Group); err != nil {
                return err
             }
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "purpose":
            if err := json.Unmarshal([]byte(v), &strct.Purpose); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if constraints (a required property) was received
    if !constraintsReceived {
        return errors.New("\"constraints\" is required but was not present")
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    return nil
}

func (strct *IsHolderItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Directive" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "directive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"directive\": ")
	if tmp, err := json.Marshal(strct.Directive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FieldId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "field_id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"field_id\": ")
	if tmp, err := json.Marshal(strct.FieldId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IsHolderItems) UnmarshalJSON(b []byte) error {
    directiveReceived := false
    field_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "directive":
            if err := json.Unmarshal([]byte(v), &strct.Directive); err != nil {
                return err
             }
            directiveReceived = true
        case "field_id":
            if err := json.Unmarshal([]byte(v), &strct.FieldId); err != nil {
                return err
             }
            field_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if directive (a required property) was received
    if !directiveReceived {
        return errors.New("\"directive\" is required but was not present")
    }
    // check if field_id (a required property) was received
    if !field_idReceived {
        return errors.New("\"field_id\" is required but was not present")
    }
    return nil
}

func (strct *PresentationDefinition) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "frame" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"frame\": ")
	if tmp, err := json.Marshal(strct.Frame); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "InputDescriptors" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "input_descriptors" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"input_descriptors\": ")
	if tmp, err := json.Marshal(strct.InputDescriptors); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "purpose" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"purpose\": ")
	if tmp, err := json.Marshal(strct.Purpose); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "submission_requirements" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"submission_requirements\": ")
	if tmp, err := json.Marshal(strct.SubmissionRequirements); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PresentationDefinition) UnmarshalJSON(b []byte) error {
    idReceived := false
    input_descriptorsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "frame":
            if err := json.Unmarshal([]byte(v), &strct.Frame); err != nil {
                return err
             }
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "input_descriptors":
            if err := json.Unmarshal([]byte(v), &strct.InputDescriptors); err != nil {
                return err
             }
            input_descriptorsReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "purpose":
            if err := json.Unmarshal([]byte(v), &strct.Purpose); err != nil {
                return err
             }
        case "submission_requirements":
            if err := json.Unmarshal([]byte(v), &strct.SubmissionRequirements); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if input_descriptors (a required property) was received
    if !input_descriptorsReceived {
        return errors.New("\"input_descriptors\" is required but was not present")
    }
    return nil
}

func (strct *PresentationDefinitionClaimFormatDesignations) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PresentationDefinitionClaimFormatDesignations) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SameSubjectItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Directive" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "directive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"directive\": ")
	if tmp, err := json.Marshal(strct.Directive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "FieldId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "field_id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"field_id\": ")
	if tmp, err := json.Marshal(strct.FieldId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SameSubjectItems) UnmarshalJSON(b []byte) error {
    directiveReceived := false
    field_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "directive":
            if err := json.Unmarshal([]byte(v), &strct.Directive); err != nil {
                return err
             }
            directiveReceived = true
        case "field_id":
            if err := json.Unmarshal([]byte(v), &strct.FieldId); err != nil {
                return err
             }
            field_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if directive (a required property) was received
    if !directiveReceived {
        return errors.New("\"directive\" is required but was not present")
    }
    // check if field_id (a required property) was received
    if !field_idReceived {
        return errors.New("\"field_id\" is required but was not present")
    }
    return nil
}

func (strct *StatusDirective) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "directive" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"directive\": ")
	if tmp, err := json.Marshal(strct.Directive); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StatusDirective) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "directive":
            if err := json.Unmarshal([]byte(v), &strct.Directive); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Statuses) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "active" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"active\": ")
	if tmp, err := json.Marshal(strct.Active); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "revoked" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"revoked\": ")
	if tmp, err := json.Marshal(strct.Revoked); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "suspended" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"suspended\": ")
	if tmp, err := json.Marshal(strct.Suspended); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Statuses) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "active":
            if err := json.Unmarshal([]byte(v), &strct.Active); err != nil {
                return err
             }
        case "revoked":
            if err := json.Unmarshal([]byte(v), &strct.Revoked); err != nil {
                return err
             }
        case "suspended":
            if err := json.Unmarshal([]byte(v), &strct.Suspended); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
