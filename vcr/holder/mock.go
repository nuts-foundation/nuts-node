// Code generated by MockGen. DO NOT EDIT.
// Source: vcr/holder/interface.go

// Package holder is a generated GoMock package.
package holder

import (
	context "context"
	reflect "reflect"

	did "github.com/nuts-foundation/go-did/did"
	vc "github.com/nuts-foundation/go-did/vc"
	leia "github.com/nuts-foundation/go-leia/v4"
	gomock "go.uber.org/mock/gomock"
)

// MockWallet is a mock of Wallet interface.
type MockWallet struct {
	ctrl     *gomock.Controller
	recorder *MockWalletMockRecorder
}

// MockWalletMockRecorder is the mock recorder for MockWallet.
type MockWalletMockRecorder struct {
	mock *MockWallet
}

// NewMockWallet creates a new mock instance.
func NewMockWallet(ctrl *gomock.Controller) *MockWallet {
	mock := &MockWallet{ctrl: ctrl}
	mock.recorder = &MockWalletMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWallet) EXPECT() *MockWalletMockRecorder {
	return m.recorder
}

// BuildPresentation mocks base method.
func (m *MockWallet) BuildPresentation(ctx context.Context, credentials []vc.VerifiableCredential, options PresentationOptions, signerDID *did.DID, validateVC bool) (*vc.VerifiablePresentation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BuildPresentation", ctx, credentials, options, signerDID, validateVC)
	ret0, _ := ret[0].(*vc.VerifiablePresentation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuildPresentation indicates an expected call of BuildPresentation.
func (mr *MockWalletMockRecorder) BuildPresentation(ctx, credentials, options, signerDID, validateVC interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildPresentation", reflect.TypeOf((*MockWallet)(nil).BuildPresentation), ctx, credentials, options, signerDID, validateVC)
}

// CanHold mocks base method.
func (m *MockWallet) CanHold(ctx context.Context, credential vc.VerifiableCredential) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CanHold", ctx, credential)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CanHold indicates an expected call of CanHold.
func (mr *MockWalletMockRecorder) CanHold(ctx, credential interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanHold", reflect.TypeOf((*MockWallet)(nil).CanHold), ctx, credential)
}

// Import mocks base method.
func (m *MockWallet) Import(collection leia.Collection) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Import", collection)
	ret0, _ := ret[0].(error)
	return ret0
}

// Import indicates an expected call of Import.
func (mr *MockWalletMockRecorder) Import(collection interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Import", reflect.TypeOf((*MockWallet)(nil).Import), collection)
}

// List mocks base method.
func (m *MockWallet) List(ctx context.Context, holderDID did.DID) ([]vc.VerifiableCredential, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, holderDID)
	ret0, _ := ret[0].([]vc.VerifiableCredential)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockWalletMockRecorder) List(ctx, holderDID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockWallet)(nil).List), ctx, holderDID)
}

// Put mocks base method.
func (m *MockWallet) Put(ctx context.Context, credential vc.VerifiableCredential) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Put", ctx, credential)
	ret0, _ := ret[0].(error)
	return ret0
}

// Put indicates an expected call of Put.
func (mr *MockWalletMockRecorder) Put(ctx, credential interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Put", reflect.TypeOf((*MockWallet)(nil).Put), ctx, credential)
}
