// Package iam provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package iam

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	JwtBearerAuthScopes = "jwtBearerAuth.Scopes"
)

// Defines values for ServiceAccessTokenRequestTokenType.
const (
	ServiceAccessTokenRequestTokenTypeBearer ServiceAccessTokenRequestTokenType = "Bearer"
	ServiceAccessTokenRequestTokenTypeDPoP   ServiceAccessTokenRequestTokenType = "DPoP"
)

// Defines values for UserAccessTokenRequestTokenType.
const (
	UserAccessTokenRequestTokenTypeBearer UserAccessTokenRequestTokenType = "Bearer"
	UserAccessTokenRequestTokenTypeDPoP   UserAccessTokenRequestTokenType = "DPoP"
)

// DPoPRequest defines model for DPoPRequest.
type DPoPRequest struct {
	// Htm The HTTP method for which the DPoP proof is requested.
	Htm string `json:"htm"`

	// Htu The URL for which the DPoP proof is requested. Query params and fragments are ignored during validation.
	Htu string `json:"htu"`

	// Token The access token for which the DPoP proof is requested.
	Token string `json:"token"`
}

// DPoPResponse defines model for DPoPResponse.
type DPoPResponse struct {
	// Dpop The DPoP proof as specified by https://datatracker.ietf.org/doc/html/rfc9449 for resource requests
	Dpop string `json:"dpop"`
}

// DPoPValidateRequest defines model for DPoPValidateRequest.
type DPoPValidateRequest struct {
	// DpopProof The DPoP Proof as specified by https://datatracker.ietf.org/doc/html/rfc9449 for resource requests
	DpopProof string `json:"dpop_proof"`

	// Method The HTTP method against which the DPoP proof is validated.
	Method string `json:"method"`

	// Thumbprint The thumbprint of the public key used to sign the DPoP proof. Base64url encoded, no padding.
	Thumbprint string `json:"thumbprint"`

	// Token The access token against which the DPoP proof is validated.
	Token string `json:"token"`

	// Url The URL against which the DPoP proof is validated. Query params and fragments are ignored during validation.
	Url string `json:"url"`
}

// DPoPValidateResponse defines model for DPoPValidateResponse.
type DPoPValidateResponse struct {
	// Reason The reason why the DPoP Proof header is invalid.
	Reason *string `json:"reason,omitempty"`

	// Valid True if the DPoP Proof header is valid for the access token and HTTP request, false if it is not.
	Valid bool `json:"valid"`
}

// ExtendedTokenIntrospectionResponse defines model for ExtendedTokenIntrospectionResponse.
type ExtendedTokenIntrospectionResponse struct {
	// Active True if the token is active, false if the token is expired, malformed etc. Required per RFC7662
	Active bool `json:"active"`

	// Aud RFC7662 - Service-specific string identifier or list of string identifiers representing the intended audience for this token, as defined in JWT [RFC7519].
	Aud *string `json:"aud,omitempty"`

	// ClientId The client (DID) the access token was issued to
	ClientId *string `json:"client_id,omitempty"`

	// Cnf The 'confirmation' claim is used in JWTs to proof the possession of a key.
	Cnf *Cnf `json:"cnf,omitempty"`

	// Exp Expiration date in seconds since UNIX epoch
	Exp *int `json:"exp,omitempty"`

	// Iat Issuance time in seconds since UNIX epoch
	Iat *int `json:"iat,omitempty"`

	// Iss Contains the DID of the authorizer. Should be equal to 'sub'
	Iss *string `json:"iss,omitempty"`

	// PresentationDefinitions Presentation Definitions, as described in Presentation Exchange specification, fulfilled to obtain the access token
	// The map key is the wallet owner (user/organization)
	PresentationDefinitions *RequiredPresentationDefinitions `json:"presentation_definitions,omitempty"`

	// PresentationSubmissions Mapping of Presentation Definition IDs that were fulfilled to Presentation Submissions.
	PresentationSubmissions *map[string]PresentationSubmission `json:"presentation_submissions,omitempty"`

	// Scope granted scopes
	Scope *string `json:"scope,omitempty"`

	// Sub Contains the DID of the resource owner
	Sub                  *string                   `json:"sub,omitempty"`
	Vps                  *[]VerifiablePresentation `json:"vps,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// RedirectResponseWithID defines model for RedirectResponseWithID.
type RedirectResponseWithID struct {
	// RedirectUri The URL to which the user-agent will be redirected after the authorization request.
	RedirectUri string `json:"redirect_uri"`

	// SessionId The session ID that can be used to retrieve the access token by the calling application.
	SessionId string `json:"session_id"`
}

// ServiceAccessTokenRequest Request for an access token for a service.
type ServiceAccessTokenRequest struct {
	// AuthorizationServer The OAuth Authorization Server's identifier as specified in RFC 8414 (section 2),
	// used to locate the OAuth2 Authorization Server metadata.
	AuthorizationServer string `json:"authorization_server"`

	// Credentials Additional credentials to present (if required by the authorizer), in addition to those in the requester's wallet.
	// They must be in the form of a Verifiable Credential in JSON form.
	// The serialized form (JWT or JSON-LD) in the resulting Verifiable Presentation depends on the capability of the authorizing party.
	// A typical use case is to provide a self-attested credential to convey information about the user that initiated the request.
	//
	// The following credential fields are automatically filled (when not present), and may be omitted:
	// - issuer, credentialSubject.id (filled with the DID of the requester)
	// - issuanceDate (filled with the current date/time)
	// - id (filled with a UUID)
	Credentials *[]VerifiableCredential `json:"credentials,omitempty"`

	// Scope The scope that will be the service for which this access token can be used.
	Scope string `json:"scope"`

	// TokenType The type of access token that is preferred, default: DPoP
	TokenType *ServiceAccessTokenRequestTokenType `json:"token_type,omitempty"`
}

// ServiceAccessTokenRequestTokenType The type of access token that is preferred, default: DPoP
type ServiceAccessTokenRequestTokenType string

// TokenIntrospectionRequest Token introspection request as described in RFC7662 section 2.1
// Alongside the defined properties, it can return values (additionalProperties) from the Verifiable Credentials that resulted from the Presentation Exchange.
type TokenIntrospectionRequest struct {
	Token string `json:"token"`
}

// UserAccessTokenRequest Request for an access token for a user.
type UserAccessTokenRequest struct {
	// AuthorizationServer The OAuth Authorization Server's identifier as specified in RFC 8414 (section 2),
	// used to locate the OAuth2 Authorization Server metadata.
	AuthorizationServer string `json:"authorization_server"`

	// PreauthorizedUser Claims about the authorized user.
	PreauthorizedUser *UserDetails `json:"preauthorized_user,omitempty"`

	// RedirectUri The URL to which the user-agent will be redirected after the authorization request.
	// This is the URL of the calling application.
	// The OAuth2 flow will finish at the /callback URL of the node and the node will redirect the user to this redirect_uri.
	RedirectUri string `json:"redirect_uri"`

	// Scope The scope that will be the service for which this access token can be used.
	Scope string `json:"scope"`

	// TokenType The type of access token that is prefered. Supported values: [Bearer, DPoP], default: DPoP
	TokenType *UserAccessTokenRequestTokenType `json:"token_type,omitempty"`
}

// UserAccessTokenRequestTokenType The type of access token that is prefered. Supported values: [Bearer, DPoP], default: DPoP
type UserAccessTokenRequestTokenType string

// UserDetails Claims about the authorized user.
type UserDetails struct {
	// Id Machine-readable identifier, uniquely identifying the user in the issuing system.
	Id string `json:"id"`

	// Name Human-readable name of the user.
	Name string `json:"name"`

	// Role Role of the user.
	Role string `json:"role"`
}

// Cnf The 'confirmation' claim is used in JWTs to proof the possession of a key.
type Cnf struct {
	// Jkt JWK thumbprint
	Jkt string `json:"jkt"`
}

// RequestOpenid4VCICredentialIssuanceJSONBody defines parameters for RequestOpenid4VCICredentialIssuance.
type RequestOpenid4VCICredentialIssuanceJSONBody struct {
	AuthorizationDetails []map[string]interface{} `json:"authorization_details"`

	// Issuer The OAuth Authorization Server's identifier, that issues the Verifiable Credentials, as specified in RFC 8414 (section 2),
	// used to locate the OAuth2 Authorization Server metadata.
	Issuer string `json:"issuer"`

	// RedirectUri The URL to which the user-agent will be redirected after the authorization request.
	RedirectUri string `json:"redirect_uri"`

	// WalletDid The DID to which the Verifiable Credential must be issued. Must be owned by the given subject.
	WalletDid string `json:"wallet_did"`
}

// IntrospectAccessTokenFormdataRequestBody defines body for IntrospectAccessToken for application/x-www-form-urlencoded ContentType.
type IntrospectAccessTokenFormdataRequestBody = TokenIntrospectionRequest

// IntrospectAccessTokenExtendedFormdataRequestBody defines body for IntrospectAccessTokenExtended for application/x-www-form-urlencoded ContentType.
type IntrospectAccessTokenExtendedFormdataRequestBody = TokenIntrospectionRequest

// ValidateDPoPProofJSONRequestBody defines body for ValidateDPoPProof for application/json ContentType.
type ValidateDPoPProofJSONRequestBody = DPoPValidateRequest

// CreateDPoPProofJSONRequestBody defines body for CreateDPoPProof for application/json ContentType.
type CreateDPoPProofJSONRequestBody = DPoPRequest

// RequestOpenid4VCICredentialIssuanceJSONRequestBody defines body for RequestOpenid4VCICredentialIssuance for application/json ContentType.
type RequestOpenid4VCICredentialIssuanceJSONRequestBody RequestOpenid4VCICredentialIssuanceJSONBody

// RequestServiceAccessTokenJSONRequestBody defines body for RequestServiceAccessToken for application/json ContentType.
type RequestServiceAccessTokenJSONRequestBody = ServiceAccessTokenRequest

// RequestUserAccessTokenJSONRequestBody defines body for RequestUserAccessToken for application/json ContentType.
type RequestUserAccessTokenJSONRequestBody = UserAccessTokenRequest

// Getter for additional properties for ExtendedTokenIntrospectionResponse. Returns the specified
// element and whether it was found
func (a ExtendedTokenIntrospectionResponse) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ExtendedTokenIntrospectionResponse
func (a *ExtendedTokenIntrospectionResponse) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ExtendedTokenIntrospectionResponse to handle AdditionalProperties
func (a *ExtendedTokenIntrospectionResponse) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["active"]; found {
		err = json.Unmarshal(raw, &a.Active)
		if err != nil {
			return fmt.Errorf("error reading 'active': %w", err)
		}
		delete(object, "active")
	}

	if raw, found := object["aud"]; found {
		err = json.Unmarshal(raw, &a.Aud)
		if err != nil {
			return fmt.Errorf("error reading 'aud': %w", err)
		}
		delete(object, "aud")
	}

	if raw, found := object["client_id"]; found {
		err = json.Unmarshal(raw, &a.ClientId)
		if err != nil {
			return fmt.Errorf("error reading 'client_id': %w", err)
		}
		delete(object, "client_id")
	}

	if raw, found := object["cnf"]; found {
		err = json.Unmarshal(raw, &a.Cnf)
		if err != nil {
			return fmt.Errorf("error reading 'cnf': %w", err)
		}
		delete(object, "cnf")
	}

	if raw, found := object["exp"]; found {
		err = json.Unmarshal(raw, &a.Exp)
		if err != nil {
			return fmt.Errorf("error reading 'exp': %w", err)
		}
		delete(object, "exp")
	}

	if raw, found := object["iat"]; found {
		err = json.Unmarshal(raw, &a.Iat)
		if err != nil {
			return fmt.Errorf("error reading 'iat': %w", err)
		}
		delete(object, "iat")
	}

	if raw, found := object["iss"]; found {
		err = json.Unmarshal(raw, &a.Iss)
		if err != nil {
			return fmt.Errorf("error reading 'iss': %w", err)
		}
		delete(object, "iss")
	}

	if raw, found := object["presentation_definitions"]; found {
		err = json.Unmarshal(raw, &a.PresentationDefinitions)
		if err != nil {
			return fmt.Errorf("error reading 'presentation_definitions': %w", err)
		}
		delete(object, "presentation_definitions")
	}

	if raw, found := object["presentation_submissions"]; found {
		err = json.Unmarshal(raw, &a.PresentationSubmissions)
		if err != nil {
			return fmt.Errorf("error reading 'presentation_submissions': %w", err)
		}
		delete(object, "presentation_submissions")
	}

	if raw, found := object["scope"]; found {
		err = json.Unmarshal(raw, &a.Scope)
		if err != nil {
			return fmt.Errorf("error reading 'scope': %w", err)
		}
		delete(object, "scope")
	}

	if raw, found := object["sub"]; found {
		err = json.Unmarshal(raw, &a.Sub)
		if err != nil {
			return fmt.Errorf("error reading 'sub': %w", err)
		}
		delete(object, "sub")
	}

	if raw, found := object["vps"]; found {
		err = json.Unmarshal(raw, &a.Vps)
		if err != nil {
			return fmt.Errorf("error reading 'vps': %w", err)
		}
		delete(object, "vps")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ExtendedTokenIntrospectionResponse to handle AdditionalProperties
func (a ExtendedTokenIntrospectionResponse) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["active"], err = json.Marshal(a.Active)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'active': %w", err)
	}

	if a.Aud != nil {
		object["aud"], err = json.Marshal(a.Aud)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'aud': %w", err)
		}
	}

	if a.ClientId != nil {
		object["client_id"], err = json.Marshal(a.ClientId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'client_id': %w", err)
		}
	}

	if a.Cnf != nil {
		object["cnf"], err = json.Marshal(a.Cnf)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cnf': %w", err)
		}
	}

	if a.Exp != nil {
		object["exp"], err = json.Marshal(a.Exp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'exp': %w", err)
		}
	}

	if a.Iat != nil {
		object["iat"], err = json.Marshal(a.Iat)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'iat': %w", err)
		}
	}

	if a.Iss != nil {
		object["iss"], err = json.Marshal(a.Iss)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'iss': %w", err)
		}
	}

	if a.PresentationDefinitions != nil {
		object["presentation_definitions"], err = json.Marshal(a.PresentationDefinitions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'presentation_definitions': %w", err)
		}
	}

	if a.PresentationSubmissions != nil {
		object["presentation_submissions"], err = json.Marshal(a.PresentationSubmissions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'presentation_submissions': %w", err)
		}
	}

	if a.Scope != nil {
		object["scope"], err = json.Marshal(a.Scope)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scope': %w", err)
		}
	}

	if a.Sub != nil {
		object["sub"], err = json.Marshal(a.Sub)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sub': %w", err)
		}
	}

	if a.Vps != nil {
		object["vps"], err = json.Marshal(a.Vps)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vps': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// IntrospectAccessTokenWithBody request with any body
	IntrospectAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IntrospectAccessTokenWithFormdataBody(ctx context.Context, body IntrospectAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IntrospectAccessTokenExtendedWithBody request with any body
	IntrospectAccessTokenExtendedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IntrospectAccessTokenExtendedWithFormdataBody(ctx context.Context, body IntrospectAccessTokenExtendedFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAccessToken request
	RetrieveAccessToken(ctx context.Context, sessionID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateDPoPProofWithBody request with any body
	ValidateDPoPProofWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateDPoPProof(ctx context.Context, body ValidateDPoPProofJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDPoPProofWithBody request with any body
	CreateDPoPProofWithBody(ctx context.Context, kid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDPoPProof(ctx context.Context, kid string, body CreateDPoPProofJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestOpenid4VCICredentialIssuanceWithBody request with any body
	RequestOpenid4VCICredentialIssuanceWithBody(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestOpenid4VCICredentialIssuance(ctx context.Context, subjectID string, body RequestOpenid4VCICredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestServiceAccessTokenWithBody request with any body
	RequestServiceAccessTokenWithBody(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestServiceAccessToken(ctx context.Context, subjectID string, body RequestServiceAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestUserAccessTokenWithBody request with any body
	RequestUserAccessTokenWithBody(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestUserAccessToken(ctx context.Context, subjectID string, body RequestUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) IntrospectAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntrospectAccessTokenWithFormdataBody(ctx context.Context, body IntrospectAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectAccessTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntrospectAccessTokenExtendedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectAccessTokenExtendedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntrospectAccessTokenExtendedWithFormdataBody(ctx context.Context, body IntrospectAccessTokenExtendedFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectAccessTokenExtendedRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAccessToken(ctx context.Context, sessionID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAccessTokenRequest(c.Server, sessionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateDPoPProofWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateDPoPProofRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateDPoPProof(ctx context.Context, body ValidateDPoPProofJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateDPoPProofRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDPoPProofWithBody(ctx context.Context, kid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDPoPProofRequestWithBody(c.Server, kid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDPoPProof(ctx context.Context, kid string, body CreateDPoPProofJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDPoPProofRequest(c.Server, kid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestOpenid4VCICredentialIssuanceWithBody(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestOpenid4VCICredentialIssuanceRequestWithBody(c.Server, subjectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestOpenid4VCICredentialIssuance(ctx context.Context, subjectID string, body RequestOpenid4VCICredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestOpenid4VCICredentialIssuanceRequest(c.Server, subjectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestServiceAccessTokenWithBody(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestServiceAccessTokenRequestWithBody(c.Server, subjectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestServiceAccessToken(ctx context.Context, subjectID string, body RequestServiceAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestServiceAccessTokenRequest(c.Server, subjectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestUserAccessTokenWithBody(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestUserAccessTokenRequestWithBody(c.Server, subjectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestUserAccessToken(ctx context.Context, subjectID string, body RequestUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestUserAccessTokenRequest(c.Server, subjectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewIntrospectAccessTokenRequestWithFormdataBody calls the generic IntrospectAccessToken builder with application/x-www-form-urlencoded body
func NewIntrospectAccessTokenRequestWithFormdataBody(server string, body IntrospectAccessTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewIntrospectAccessTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewIntrospectAccessTokenRequestWithBody generates requests for IntrospectAccessToken with any type of body
func NewIntrospectAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/auth/v2/accesstoken/introspect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIntrospectAccessTokenExtendedRequestWithFormdataBody calls the generic IntrospectAccessTokenExtended builder with application/x-www-form-urlencoded body
func NewIntrospectAccessTokenExtendedRequestWithFormdataBody(server string, body IntrospectAccessTokenExtendedFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewIntrospectAccessTokenExtendedRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewIntrospectAccessTokenExtendedRequestWithBody generates requests for IntrospectAccessTokenExtended with any type of body
func NewIntrospectAccessTokenExtendedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/auth/v2/accesstoken/introspect_extended")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveAccessTokenRequest generates requests for RetrieveAccessToken
func NewRetrieveAccessTokenRequest(server string, sessionID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionID", runtime.ParamLocationPath, sessionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/auth/v2/accesstoken/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateDPoPProofRequest calls the generic ValidateDPoPProof builder with application/json body
func NewValidateDPoPProofRequest(server string, body ValidateDPoPProofJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateDPoPProofRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateDPoPProofRequestWithBody generates requests for ValidateDPoPProof with any type of body
func NewValidateDPoPProofRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/auth/v2/dpop_validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDPoPProofRequest calls the generic CreateDPoPProof builder with application/json body
func NewCreateDPoPProofRequest(server string, kid string, body CreateDPoPProofJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDPoPProofRequestWithBody(server, kid, "application/json", bodyReader)
}

// NewCreateDPoPProofRequestWithBody generates requests for CreateDPoPProof with any type of body
func NewCreateDPoPProofRequestWithBody(server string, kid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = kid

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/auth/v2/%s/dpop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRequestOpenid4VCICredentialIssuanceRequest calls the generic RequestOpenid4VCICredentialIssuance builder with application/json body
func NewRequestOpenid4VCICredentialIssuanceRequest(server string, subjectID string, body RequestOpenid4VCICredentialIssuanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestOpenid4VCICredentialIssuanceRequestWithBody(server, subjectID, "application/json", bodyReader)
}

// NewRequestOpenid4VCICredentialIssuanceRequestWithBody generates requests for RequestOpenid4VCICredentialIssuance with any type of body
func NewRequestOpenid4VCICredentialIssuanceRequestWithBody(server string, subjectID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectID", runtime.ParamLocationPath, subjectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/auth/v2/%s/request-credential", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRequestServiceAccessTokenRequest calls the generic RequestServiceAccessToken builder with application/json body
func NewRequestServiceAccessTokenRequest(server string, subjectID string, body RequestServiceAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestServiceAccessTokenRequestWithBody(server, subjectID, "application/json", bodyReader)
}

// NewRequestServiceAccessTokenRequestWithBody generates requests for RequestServiceAccessToken with any type of body
func NewRequestServiceAccessTokenRequestWithBody(server string, subjectID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectID", runtime.ParamLocationPath, subjectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/auth/v2/%s/request-service-access-token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRequestUserAccessTokenRequest calls the generic RequestUserAccessToken builder with application/json body
func NewRequestUserAccessTokenRequest(server string, subjectID string, body RequestUserAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestUserAccessTokenRequestWithBody(server, subjectID, "application/json", bodyReader)
}

// NewRequestUserAccessTokenRequestWithBody generates requests for RequestUserAccessToken with any type of body
func NewRequestUserAccessTokenRequestWithBody(server string, subjectID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subjectID", runtime.ParamLocationPath, subjectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/auth/v2/%s/request-user-access-token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// IntrospectAccessTokenWithBodyWithResponse request with any body
	IntrospectAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectAccessTokenResponse, error)

	IntrospectAccessTokenWithFormdataBodyWithResponse(ctx context.Context, body IntrospectAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectAccessTokenResponse, error)

	// IntrospectAccessTokenExtendedWithBodyWithResponse request with any body
	IntrospectAccessTokenExtendedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectAccessTokenExtendedResponse, error)

	IntrospectAccessTokenExtendedWithFormdataBodyWithResponse(ctx context.Context, body IntrospectAccessTokenExtendedFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectAccessTokenExtendedResponse, error)

	// RetrieveAccessTokenWithResponse request
	RetrieveAccessTokenWithResponse(ctx context.Context, sessionID string, reqEditors ...RequestEditorFn) (*RetrieveAccessTokenResponse, error)

	// ValidateDPoPProofWithBodyWithResponse request with any body
	ValidateDPoPProofWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateDPoPProofResponse, error)

	ValidateDPoPProofWithResponse(ctx context.Context, body ValidateDPoPProofJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateDPoPProofResponse, error)

	// CreateDPoPProofWithBodyWithResponse request with any body
	CreateDPoPProofWithBodyWithResponse(ctx context.Context, kid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDPoPProofResponse, error)

	CreateDPoPProofWithResponse(ctx context.Context, kid string, body CreateDPoPProofJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDPoPProofResponse, error)

	// RequestOpenid4VCICredentialIssuanceWithBodyWithResponse request with any body
	RequestOpenid4VCICredentialIssuanceWithBodyWithResponse(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestOpenid4VCICredentialIssuanceResponse, error)

	RequestOpenid4VCICredentialIssuanceWithResponse(ctx context.Context, subjectID string, body RequestOpenid4VCICredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestOpenid4VCICredentialIssuanceResponse, error)

	// RequestServiceAccessTokenWithBodyWithResponse request with any body
	RequestServiceAccessTokenWithBodyWithResponse(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestServiceAccessTokenResponse, error)

	RequestServiceAccessTokenWithResponse(ctx context.Context, subjectID string, body RequestServiceAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestServiceAccessTokenResponse, error)

	// RequestUserAccessTokenWithBodyWithResponse request with any body
	RequestUserAccessTokenWithBodyWithResponse(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestUserAccessTokenResponse, error)

	RequestUserAccessTokenWithResponse(ctx context.Context, subjectID string, body RequestUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestUserAccessTokenResponse, error)
}

type IntrospectAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenIntrospectionResponse
}

// Status returns HTTPResponse.Status
func (r IntrospectAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IntrospectAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IntrospectAccessTokenExtendedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExtendedTokenIntrospectionResponse
}

// Status returns HTTPResponse.Status
func (r IntrospectAccessTokenExtendedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IntrospectAccessTokenExtendedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAccessTokenResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *TokenResponse
	ApplicationproblemJSONDefault *struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
}

// Status returns HTTPResponse.Status
func (r RetrieveAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateDPoPProofResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *DPoPValidateResponse
	ApplicationproblemJSONDefault *struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
}

// Status returns HTTPResponse.Status
func (r ValidateDPoPProofResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateDPoPProofResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDPoPProofResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DPoPResponse
}

// Status returns HTTPResponse.Status
func (r CreateDPoPProofResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDPoPProofResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestOpenid4VCICredentialIssuanceResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *RedirectResponse
	ApplicationproblemJSONDefault *struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
}

// Status returns HTTPResponse.Status
func (r RequestOpenid4VCICredentialIssuanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestOpenid4VCICredentialIssuanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestServiceAccessTokenResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *TokenResponse
	ApplicationproblemJSONDefault *struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
}

// Status returns HTTPResponse.Status
func (r RequestServiceAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestServiceAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestUserAccessTokenResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *RedirectResponseWithID
	ApplicationproblemJSONDefault *struct {
		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Status HTTP statuscode
		Status float32 `json:"status"`

		// Title A short, human-readable summary of the problem type.
		Title string `json:"title"`
	}
}

// Status returns HTTPResponse.Status
func (r RequestUserAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestUserAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// IntrospectAccessTokenWithBodyWithResponse request with arbitrary body returning *IntrospectAccessTokenResponse
func (c *ClientWithResponses) IntrospectAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectAccessTokenResponse, error) {
	rsp, err := c.IntrospectAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) IntrospectAccessTokenWithFormdataBodyWithResponse(ctx context.Context, body IntrospectAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectAccessTokenResponse, error) {
	rsp, err := c.IntrospectAccessTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectAccessTokenResponse(rsp)
}

// IntrospectAccessTokenExtendedWithBodyWithResponse request with arbitrary body returning *IntrospectAccessTokenExtendedResponse
func (c *ClientWithResponses) IntrospectAccessTokenExtendedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectAccessTokenExtendedResponse, error) {
	rsp, err := c.IntrospectAccessTokenExtendedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectAccessTokenExtendedResponse(rsp)
}

func (c *ClientWithResponses) IntrospectAccessTokenExtendedWithFormdataBodyWithResponse(ctx context.Context, body IntrospectAccessTokenExtendedFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectAccessTokenExtendedResponse, error) {
	rsp, err := c.IntrospectAccessTokenExtendedWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectAccessTokenExtendedResponse(rsp)
}

// RetrieveAccessTokenWithResponse request returning *RetrieveAccessTokenResponse
func (c *ClientWithResponses) RetrieveAccessTokenWithResponse(ctx context.Context, sessionID string, reqEditors ...RequestEditorFn) (*RetrieveAccessTokenResponse, error) {
	rsp, err := c.RetrieveAccessToken(ctx, sessionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAccessTokenResponse(rsp)
}

// ValidateDPoPProofWithBodyWithResponse request with arbitrary body returning *ValidateDPoPProofResponse
func (c *ClientWithResponses) ValidateDPoPProofWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateDPoPProofResponse, error) {
	rsp, err := c.ValidateDPoPProofWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateDPoPProofResponse(rsp)
}

func (c *ClientWithResponses) ValidateDPoPProofWithResponse(ctx context.Context, body ValidateDPoPProofJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateDPoPProofResponse, error) {
	rsp, err := c.ValidateDPoPProof(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateDPoPProofResponse(rsp)
}

// CreateDPoPProofWithBodyWithResponse request with arbitrary body returning *CreateDPoPProofResponse
func (c *ClientWithResponses) CreateDPoPProofWithBodyWithResponse(ctx context.Context, kid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDPoPProofResponse, error) {
	rsp, err := c.CreateDPoPProofWithBody(ctx, kid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDPoPProofResponse(rsp)
}

func (c *ClientWithResponses) CreateDPoPProofWithResponse(ctx context.Context, kid string, body CreateDPoPProofJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDPoPProofResponse, error) {
	rsp, err := c.CreateDPoPProof(ctx, kid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDPoPProofResponse(rsp)
}

// RequestOpenid4VCICredentialIssuanceWithBodyWithResponse request with arbitrary body returning *RequestOpenid4VCICredentialIssuanceResponse
func (c *ClientWithResponses) RequestOpenid4VCICredentialIssuanceWithBodyWithResponse(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestOpenid4VCICredentialIssuanceResponse, error) {
	rsp, err := c.RequestOpenid4VCICredentialIssuanceWithBody(ctx, subjectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestOpenid4VCICredentialIssuanceResponse(rsp)
}

func (c *ClientWithResponses) RequestOpenid4VCICredentialIssuanceWithResponse(ctx context.Context, subjectID string, body RequestOpenid4VCICredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestOpenid4VCICredentialIssuanceResponse, error) {
	rsp, err := c.RequestOpenid4VCICredentialIssuance(ctx, subjectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestOpenid4VCICredentialIssuanceResponse(rsp)
}

// RequestServiceAccessTokenWithBodyWithResponse request with arbitrary body returning *RequestServiceAccessTokenResponse
func (c *ClientWithResponses) RequestServiceAccessTokenWithBodyWithResponse(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestServiceAccessTokenResponse, error) {
	rsp, err := c.RequestServiceAccessTokenWithBody(ctx, subjectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestServiceAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) RequestServiceAccessTokenWithResponse(ctx context.Context, subjectID string, body RequestServiceAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestServiceAccessTokenResponse, error) {
	rsp, err := c.RequestServiceAccessToken(ctx, subjectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestServiceAccessTokenResponse(rsp)
}

// RequestUserAccessTokenWithBodyWithResponse request with arbitrary body returning *RequestUserAccessTokenResponse
func (c *ClientWithResponses) RequestUserAccessTokenWithBodyWithResponse(ctx context.Context, subjectID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestUserAccessTokenResponse, error) {
	rsp, err := c.RequestUserAccessTokenWithBody(ctx, subjectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestUserAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) RequestUserAccessTokenWithResponse(ctx context.Context, subjectID string, body RequestUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestUserAccessTokenResponse, error) {
	rsp, err := c.RequestUserAccessToken(ctx, subjectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestUserAccessTokenResponse(rsp)
}

// ParseIntrospectAccessTokenResponse parses an HTTP response from a IntrospectAccessTokenWithResponse call
func ParseIntrospectAccessTokenResponse(rsp *http.Response) (*IntrospectAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IntrospectAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenIntrospectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIntrospectAccessTokenExtendedResponse parses an HTTP response from a IntrospectAccessTokenExtendedWithResponse call
func ParseIntrospectAccessTokenExtendedResponse(rsp *http.Response) (*IntrospectAccessTokenExtendedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IntrospectAccessTokenExtendedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExtendedTokenIntrospectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRetrieveAccessTokenResponse parses an HTTP response from a RetrieveAccessTokenWithResponse call
func ParseRetrieveAccessTokenResponse(rsp *http.Response) (*RetrieveAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Status HTTP statuscode
			Status float32 `json:"status"`

			// Title A short, human-readable summary of the problem type.
			Title string `json:"title"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseValidateDPoPProofResponse parses an HTTP response from a ValidateDPoPProofWithResponse call
func ParseValidateDPoPProofResponse(rsp *http.Response) (*ValidateDPoPProofResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateDPoPProofResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DPoPValidateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Status HTTP statuscode
			Status float32 `json:"status"`

			// Title A short, human-readable summary of the problem type.
			Title string `json:"title"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDPoPProofResponse parses an HTTP response from a CreateDPoPProofWithResponse call
func ParseCreateDPoPProofResponse(rsp *http.Response) (*CreateDPoPProofResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDPoPProofResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DPoPResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRequestOpenid4VCICredentialIssuanceResponse parses an HTTP response from a RequestOpenid4VCICredentialIssuanceWithResponse call
func ParseRequestOpenid4VCICredentialIssuanceResponse(rsp *http.Response) (*RequestOpenid4VCICredentialIssuanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestOpenid4VCICredentialIssuanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Status HTTP statuscode
			Status float32 `json:"status"`

			// Title A short, human-readable summary of the problem type.
			Title string `json:"title"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRequestServiceAccessTokenResponse parses an HTTP response from a RequestServiceAccessTokenWithResponse call
func ParseRequestServiceAccessTokenResponse(rsp *http.Response) (*RequestServiceAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestServiceAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Status HTTP statuscode
			Status float32 `json:"status"`

			// Title A short, human-readable summary of the problem type.
			Title string `json:"title"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRequestUserAccessTokenResponse parses an HTTP response from a RequestUserAccessTokenWithResponse call
func ParseRequestUserAccessTokenResponse(rsp *http.Response) (*RequestUserAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestUserAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RedirectResponseWithID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Status HTTP statuscode
			Status float32 `json:"status"`

			// Title A short, human-readable summary of the problem type.
			Title string `json:"title"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}
